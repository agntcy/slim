#!/usr/bin/env node
/**
 * create_critical_cve_issues.js
 * Scans downloaded Trivy SARIF artifacts and creates GitHub issues for unique CRITICAL CVEs.
 */
const fs = require('fs');
const glob = require('glob');
const { Octokit } = require('@octokit/rest');

function main() {
  const token = process.env.GITHUB_TOKEN;
  if (!token) {
    console.error('GITHUB_TOKEN not set');
    process.exit(1);
  }
  const repoSlug = process.env.GITHUB_REPOSITORY;
  if (!repoSlug) {
    console.error('GITHUB_REPOSITORY not set');
    process.exit(1);
  }
  const [owner, repo] = repoSlug.split('/');
  const octokit = new Octokit({ auth: token });
  const sarifFiles = glob.sync('trivy-artifacts/*/trivy-*.sarif');
  if (sarifFiles.length === 0) {
    console.log('No SARIF files found');
    return;
  }
  const criticalFindings = [];
  for (const file of sarifFiles) {
    try {
      const sarif = JSON.parse(fs.readFileSync(file, 'utf8'));
      for (const run of sarif.runs || []) {
        const rules = (run.tool && run.tool.driver && run.tool.driver.rules) || [];
        for (const result of run.results || []) {
          const rule = rules[result.ruleIndex];
          if (!rule) continue;
          const tags = ((rule.properties || {}).tags) || [];
          if (tags.includes('CRITICAL')) {
            const cve = rule.id || result.ruleId;
            const level = result.level;
            const message = (result.message && result.message.text) || '';
            const pkgMatch = message.match(/Package:\s([^\n]+)/);
            const fixMatch = message.match(/Fixed Version:\s([^\n]+)/);
            criticalFindings.push({ cve, level, package: pkgMatch ? pkgMatch[1] : 'unknown', fixed: fixMatch ? fixMatch[1] : 'unknown', file });
          }
        }
      }
    } catch (e) {
      console.error(`Failed to parse ${file}:`, e);
    }
  }
  if (criticalFindings.length === 0) {
    console.log('No critical CVEs detected');
    return;
  }
  const unique = Object.values(criticalFindings.reduce((acc, f) => { acc[f.cve] = acc[f.cve] || f; return acc; }, {}));
  console.log(`Unique critical CVEs: ${unique.map(u => u.cve).join(', ')}`);

  octokit.paginate(octokit.issues.listForRepo, { owner, repo, state: 'open', per_page: 100 })
    .then(existing => {
      const existingTitles = new Set(existing.map(i => i.title));
      return Promise.all(unique.map(finding => {
        const title = `CRITICAL CVE ${finding.cve} in image scan`;
        if (existingTitles.has(title)) {
          console.log(`Issue already exists for ${finding.cve}`);
          return null;
        }
        const body = [
          'Automated security scan detected a CRITICAL vulnerability.',
          '',
          `CVE: ${finding.cve}`,
          `Package: ${finding.package}`,
          `Fixed Version: ${finding.fixed}`,
          `Severity Level (SARIF level): ${finding.level}`,
          `Source SARIF file: ${finding.file}`,
          'Generated by nightly container security scan workflow.',
          '',
          'Action items:',
          '- [ ] Assess exploitability for our deployment context',
          '- [ ] Upgrade to fixed version or apply mitigation',
          '- [ ] Verify remediation and close issue',
          '',
          'This issue was created automatically. Edit as needed.'
        ].join('\n');
        return octokit.issues.create({ owner, repo, title, body, labels: ['security', 'critical', 'cve'] })
          .then(r => console.log(`Created issue: ${r.data.html_url}`));
      }));
    })
    .catch(err => {
      console.error('Failed to list existing issues:', err);
      process.exit(1);
    });
}

if (require.main === module) {
  main();
}
