// Copyright AGNTCY Contributors (https://github.com/agntcy)
// SPDX-License-Identifier: Apache-2.0

use anyhow::{Context, Result};
use heck::ToSnakeCase;
use prost::Message;
use prost_types::compiler::{
    CodeGeneratorRequest, CodeGeneratorResponse, code_generator_response::File,
};
use std::io::{self, Read, Write};

// --- TEMPLATE DEFINITIONS ---

const FILE_TEMPLATE: &str = r#"# Generated by protoc-srpc-plugin
# This file is generated from an embedded template. Do not edit directly.

import abc
import srpc # Assuming srpc is the custom RPC library
from . import {{PB2_MODULE_NAME}} as pb2

{{SERVICE_DEFINITIONS}}

{{ADD_SERVICER_FUNCTIONS}}
"#;

const SERVICE_STUB_TEMPLATE: &str = r#"
class {{SERVICE_NAME}}Stub:
    """Client stub for {{SERVICE_NAME}}."""
    def __init__(self, channel):
        """Constructor.

        Args:
            channel: A srpc.Channel.
        """
{{METHOD_STUB_INITIALIZERS}}
"#;

const METHOD_STUB_INITIALIZER_TEMPLATE: &str = r#"        self.{{METHOD_NAME}} = channel.{{RPC_TYPE}}(
            "/{{PACKAGE_NAME}}.{{SERVICE_NAME}}/{{METHOD_NAME}}",
            request_serializer=pb2.{{INPUT_TYPE}}.SerializeToString,
            response_deserializer=pb2.{{OUTPUT_TYPE}}.FromString,
        )
"#;

const SERVICE_SERVICER_TEMPLATE: &str = r#"
class {{SERVICE_NAME}}Servicer(abc.ABC):
    """Server servicer for {{SERVICE_NAME}}. Implement this class to provide your service logic."""

{{METHOD_SERVICERS}}
"#;

const METHOD_SERVICER_TEMPLATE: &str = r#"    @abc.abstractmethod
    def {{METHOD_NAME}}(self, {{REQUEST_ARG}}, context):
        """Method for {{METHOD_NAME}}. Implement your service logic here."""
        raise NotImplementedError("Method not implemented!")
"#;

const ADD_SERVICER_FUNCTION_TEMPLATE: &str = r#"
def add_{{SERVICE_NAME}}Servicer_to_server(servicer, server: srpc.Server):
    rpc_method_handlers = {
{{RPC_METHOD_HANDLERS}}
    }

    server.register_method_handlers(
        "{{PACKAGE_NAME}}.{{SERVICE_NAME}}",
        rpc_method_handlers,
    )
"#;

const RPC_METHOD_HANDLER_TEMPLATE: &str = r#"        "{{METHOD_NAME}}": srpc.{{RPC_TYPE}}_rpc_method_handler(
            handler=servicer.{{METHOD_NAME}},
            request_deserializer=pb2.{{INPUT_TYPE}}.FromString,
            response_serializer=pb2.{{OUTPUT_TYPE}}.SerializeToString,
        ),
"#;

// --- END TEMPLATE DEFINITIONS ---

/// Main entry point for the protoc plugin.
/// Reads CodeGeneratorRequest from stdin, generates Python code,
/// and writes CodeGeneratorResponse to stdout.
fn main() -> Result<()> {
    // Read the CodeGeneratorRequest from stdin
    let mut input_bytes = vec![];
    io::stdin().read_to_end(&mut input_bytes)?;

    // Create a code generator request from the input bytes
    let request = CodeGeneratorRequest::decode(&input_bytes[..])
        .context("Failed to decode CodeGeneratorRequest")?;

    eprintln!("Request: {:?}", request);

    let mut response = CodeGeneratorResponse::default();

    // Iterate through each .proto file provided in the request
    for file_descriptor in request.proto_file {
        // Only process files that are explicitly requested for generation
        if !request
            .file_to_generate
            .contains(&file_descriptor.name.clone().context("Missing file name")?)
        {
            continue;
        }

        let package_name = file_descriptor
            .package
            .clone()
            .context("Missing package name")?;
        let file_name_base = file_descriptor
            .name
            .as_ref()
            .and_then(|name| name.strip_suffix(".proto"))
            .map(|name| name.to_snake_case())
            .unwrap_or_else(|| "unknown_proto".to_string());

        let pb2_module_name = format!("{}_pb2", file_name_base);

        // The generated Python file will be named after the proto file,
        // with a '_pb2_srpc' suffix
        let output_file_name = format!("{}_pb2_srpc.py", file_name_base);
        let mut service_definitions_content = String::new();
        let mut add_servicer_functions_content = String::new();
        let mut services_found = false;

        // Iterate through services defined in the current .proto file
        for service in file_descriptor.service {
            services_found = true;
            let service_name = service.name.clone().context("Service name missing")?;

            let mut method_stub_initializers_content = String::new();
            let mut method_servicers_content = String::new();
            let mut rpc_method_handlers_content = String::new();

            // Generate methods for the client stub and server servicer
            for method in service.method {
                let method_name = method.name.clone().context("Method name missing")?;
                let input_type = method.input_type.clone().context("Input type missing")?;
                let output_type = method.output_type.clone().context("Output type missing")?;

                // Extract just the type name without package prefix
                let input_type_short = input_type.split('.').last().unwrap_or(&input_type);
                let output_type_short = output_type.split('.').last().unwrap_or(&output_type);

                let is_client_streaming = method.client_streaming.unwrap_or(false);
                let is_server_streaming = method.server_streaming.unwrap_or(false);

                let rpc_type = match (is_client_streaming, is_server_streaming) {
                    (false, false) => "unary_unary",
                    (false, true) => "unary_stream",
                    (true, false) => "stream_unary",
                    (true, true) => "stream_stream",
                };

                let request_arg = if is_client_streaming {
                    "request_iterator"
                } else {
                    "request"
                };

                // Populate method stub initializer template
                let current_method_stub_initializer = METHOD_STUB_INITIALIZER_TEMPLATE
                    .replace("{{METHOD_NAME}}", &method_name)
                    .replace("{{RPC_TYPE}}", rpc_type)
                    .replace("{{PACKAGE_NAME}}", &package_name)
                    .replace("{{SERVICE_NAME}}", &service_name)
                    .replace("{{INPUT_TYPE}}", input_type_short)
                    .replace("{{OUTPUT_TYPE}}", output_type_short);
                method_stub_initializers_content.push_str(&current_method_stub_initializer);

                // Populate method servicer template
                let current_method_servicer = METHOD_SERVICER_TEMPLATE
                    .replace("{{METHOD_NAME}}", &method_name)
                    .replace("{{REQUEST_ARG}}", request_arg)
                    .replace("{{INPUT_TYPE}}", input_type_short); // Input type is still useful for type hints
                method_servicers_content.push_str(&current_method_servicer);

                // Populate RPC method handler template
                let current_rpc_method_handler = RPC_METHOD_HANDLER_TEMPLATE
                    .replace("{{METHOD_NAME}}", &method_name)
                    .replace("{{RPC_TYPE}}", rpc_type)
                    .replace("{{INPUT_TYPE}}", input_type_short)
                    .replace("{{OUTPUT_TYPE}}", output_type_short);
                rpc_method_handlers_content.push_str(&current_rpc_method_handler);
            }

            // Populate service stub template
            let current_service_stub = SERVICE_STUB_TEMPLATE
                .replace("{{SERVICE_NAME}}", &service_name)
                .replace(
                    "{{METHOD_STUB_INITIALIZERS}}",
                    &method_stub_initializers_content,
                );
            service_definitions_content.push_str(&current_service_stub);

            // Populate service servicer template
            let current_service_servicer = SERVICE_SERVICER_TEMPLATE
                .replace("{{SERVICE_NAME}}", &service_name)
                .replace("{{METHOD_SERVICERS}}", &method_servicers_content);
            service_definitions_content.push_str(&current_service_servicer);

            // Populate add servicer function template
            let current_add_servicer_function = ADD_SERVICER_FUNCTION_TEMPLATE
                .replace("{{SERVICE_NAME}}", &service_name)
                .replace("{{PACKAGE_NAME}}", &package_name)
                .replace("{{RPC_METHOD_HANDLERS}}", &rpc_method_handlers_content);
            add_servicer_functions_content.push_str(&current_add_servicer_function);
        }

        // Only add a file to the response if services were found and generated
        if services_found {
            let final_content = FILE_TEMPLATE
                .replace("{{PB2_MODULE_NAME}}", &pb2_module_name)
                .replace("{{SERVICE_DEFINITIONS}}", &service_definitions_content)
                .replace(
                    "{{ADD_SERVICER_FUNCTIONS}}",
                    &add_servicer_functions_content,
                );

            response.file.push(File {
                name: Some(output_file_name),
                content: Some(final_content),
                ..Default::default()
            });
        }
    }

    // Write the CodeGeneratorResponse to stdout
    let output_bytes = response.encode_to_vec();
    io::stdout().write_all(&output_bytes)?;

    Ok(())
}
