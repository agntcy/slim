# Copyright AGNTCY Contributors (https://github.com/agntcy)
# SPDX-License-Identifier: Apache-2.0

version: '3'

includes:
  rust:
    taskfile: ../../../tasks/rust.yaml
    internal: true
  adapter:
    taskfile: ../rust/Taskfile.yaml
    internal: false
  tools:
    taskfile: ../../../tasks/tools.yaml
    internal: true
    flatten: true

vars:
  # Rust bindings directory
  BINDINGS_DIR: "{{.TASKFILE_DIR}}/../rust"
  
  # Rust library name
  LIB_NAME: slim_bindings
  
  # Build profile (debug or release)
  PROFILE: '{{.PROFILE | default "release"}}'
  RELEASE:
    sh: '[[ {{.PROFILE}} == "release" ]] && echo "--release" || echo ""'
  
  # Current target
  CURRENT_TARGET:
    sh: 'rustc -vV | sed -n "s|host: ||p"'
  TARGET: "{{.TARGET | default .CURRENT_TARGET}}"
  
  # Target directory for built libraries
  TARGET_DIR: "{{.BINDINGS_DIR}}/../../target"
  LIB_PATH: "{{.TARGET_DIR}}/{{.TARGET}}/{{.PROFILE}}"
  
  # Runtimes directory for NuGet packaging
  RUNTIMES_DIR: "{{.TASKFILE_DIR}}/runtimes"
  
  # Generated bindings directory
  GENERATED_DIR: "{{.TASKFILE_DIR}}/Slim/generated"
  
  # Supported platforms for NuGet packaging
  # Format: TARGET|RID|LIB_EXT
  PLATFORMS: |
    x86_64-unknown-linux-gnu|linux-x64|so
    aarch64-unknown-linux-gnu|linux-arm64|so
    x86_64-unknown-linux-musl|linux-musl-x64|so
    aarch64-unknown-linux-musl|linux-musl-arm64|so
    x86_64-apple-darwin|osx-x64|dylib
    aarch64-apple-darwin|osx-arm64|dylib
    x86_64-pc-windows-gnu|win-x64|dll
    x86_64-pc-windows-msvc|win-x64|dll
    aarch64-pc-windows-msvc|win-arm64|dll

env:
  PATH: "{{.TOOLS_INSTALL_DIR}}/zig:{{.PATH}}"

tasks:
  default:
    desc: "List available tasks"
    cmds:
      - task -l

  _get-lib-info:
    desc: "Internal: Get library path, RID, and name for current platform"
    internal: true
    vars:
      PROFILE_VAR: '{{.PROFILE | default "release"}}'
    cmds:
      - |
        TARGET="{{.CURRENT_TARGET}}"
        echo "{{.PLATFORMS}}" | while IFS='|' read -r target rid ext; do
          if [[ "$target" == "$TARGET" ]]; then
            case "$ext" in
              so|dylib) lib_name="lib{{.LIB_NAME}}.$ext" ;;
              dll) lib_name="{{.LIB_NAME}}.$ext" ;;
            esac
            lib_path="{{.TARGET_DIR}}/$target/{{.PROFILE_VAR}}/$lib_name"
            echo "$lib_path|$rid|$lib_name"
            exit 0
          fi
        done
        echo "ERROR: Target $TARGET not found in PLATFORMS" >&2
        exit 1
    silent: true

  install-uniffi-bindgen-cs:
    desc: "Install uniffi-bindgen-cs for C# bindings generation"
    status:
      - which uniffi-bindgen-cs
    cmds:
      - cargo install uniffi-bindgen-cs --git https://github.com/NordSecurity/uniffi-bindgen-cs.git --tag v0.9.0+v0.28.3
    silent: true

  build:rust:all:
    desc: "Build Rust libraries for all target platforms"
    cmds:
      - |
        echo "{{.PLATFORMS}}" | while IFS='|' read -r target rid ext; do
          [[ -n "$target" ]] && task adapter:bindings:build:all TARGET="$target" PROFILE={{.PROFILE}}
        done
    silent: true

  generate:
    desc: "Generate C# bindings using uniffi-bindgen-cs"
    deps:
      - install-uniffi-bindgen-cs
    cmds:
      - |
        # Determine library file to use for binding generation
        if [[ -n "{{.BINDGEN_LIB}}" ]]; then
          lib_file="{{.BINDGEN_LIB}}"
        else
          task adapter:bindings:build:all TARGET={{.CURRENT_TARGET}} PROFILE=release
          # uniffi-bindgen-cs requires .a (static library) to extract UniFFI metadata
          lib_file="{{.TARGET_DIR}}/{{.CURRENT_TARGET}}/release/lib{{.LIB_NAME}}.a"
        fi
        
        [[ ! -f "$lib_file" ]] && echo "ERROR: Library not found: $lib_file" && exit 1
        
        rm -rf {{.GENERATED_DIR}}
        mkdir -p {{.GENERATED_DIR}}
        uniffi-bindgen-cs --library --out-dir {{.GENERATED_DIR}} "$lib_file"
        
        if [[ ! -f "{{.GENERATED_DIR}}/slim_bindings.cs" ]]; then
          echo "ERROR: Failed to generate slim_bindings.cs"
          exit 1
        fi
        echo "Bindings generated successfully"
    silent: true

  copy:runtimes:from-artifacts:
    desc: "Copy native libraries from artifacts to runtimes directory (unified for CI and local dev)"
    cmds:
      - rm -rf {{.RUNTIMES_DIR}}
      - mkdir -p {{.RUNTIMES_DIR}}
      - |
        # Determine source directory: ARTIFACTS_DIR (CI) or TARGET_DIR (local)
        if [[ -n "{{.ARTIFACTS_DIR}}" && -d "{{.ARTIFACTS_DIR}}" ]]; then
          SOURCE_DIR="{{.ARTIFACTS_DIR}}"
          SOURCE_TYPE="artifacts"
        elif [[ -d "{{.TARGET_DIR}}" ]]; then
          SOURCE_DIR="{{.TARGET_DIR}}"
          SOURCE_TYPE="local"
        else
          echo "ERROR: Neither ARTIFACTS_DIR nor TARGET_DIR exists"
          exit 1
        fi
        
        # Determine if we're filtering to a single target
        FILTER_TARGET="{{.TARGET}}"
        if [[ -n "$FILTER_TARGET" ]]; then
          echo "Copying runtime library for $FILTER_TARGET from $SOURCE_TYPE..."
        else
          echo "Copying runtime libraries for all platforms from $SOURCE_TYPE..."
        fi
        
        # Iterate through target directories
        # For artifacts: bindings-* directories
        # For local: target triple directories under TARGET_DIR
        if [[ "$SOURCE_TYPE" == "artifacts" ]]; then
          SEARCH_PATTERN="$SOURCE_DIR/bindings-*"
        else
          SEARCH_PATTERN="$SOURCE_DIR/*"
        fi
        
        for target_dir in $SEARCH_PATTERN; do
          if [[ ! -d "$target_dir" ]]; then
            continue
          fi
          
          # Extract target triple from directory name
          if [[ "$SOURCE_TYPE" == "artifacts" ]]; then
            target=$(basename "$target_dir" | sed 's/^bindings-//')
            artifact_dir="$target_dir"
          else
            target=$(basename "$target_dir")
            artifact_dir="$target_dir/{{.PROFILE}}"
            if [[ ! -d "$artifact_dir" ]]; then
              continue
            fi
          fi
          
          # Skip if filtering and this isn't the target we want
          if [[ -n "$FILTER_TARGET" && "$target" != "$FILTER_TARGET" ]]; then
            continue
          fi
          
          # Look up the target in PLATFORMS to get RID and extension
          rid=""
          ext=""
          while IFS='|' read -r platform_target platform_rid platform_ext; do
            if [[ "$platform_target" == "$target" ]]; then
              rid="$platform_rid"
              ext="$platform_ext"
              break
            fi
          done <<< "{{.PLATFORMS}}"
          
          if [[ -z "$rid" || -z "$ext" ]]; then
            continue
          fi
          
          echo "Processing $target..."
          
          # Determine library name patterns
          case "$ext" in
            so|dylib) 
              lib_pattern="lib{{.LIB_NAME}}*.$ext"
              lib_name="lib{{.LIB_NAME}}.$ext"
              ;;
            dll) 
              lib_pattern="{{.LIB_NAME}}*.$ext"
              lib_name="{{.LIB_NAME}}.$ext"
              ;;
          esac
          
          # Find the runtime library
          src=$(find "$artifact_dir" -maxdepth 1 -name "$lib_pattern" -type f | head -1)
          
          if [[ -z "$src" || ! -f "$src" ]]; then
            echo "  WARNING: Runtime library not found (pattern: $lib_pattern)"
            continue
          fi
          
          # Copy to runtimes directory
          runtime_dir="{{.RUNTIMES_DIR}}/$rid/native"
          mkdir -p "$runtime_dir"
          cp "$src" "$runtime_dir/$lib_name"
          echo "  âœ“ Copied to $rid/native/$lib_name"
        done
        
        echo ""
        echo "Runtime libraries copied:"
        find {{.RUNTIMES_DIR}} -type f -ls || true
    silent: true

  copy:runtime:current:
    desc: "Copy native library for current platform to runtimes directory (for local development)"
    deps:
      - generate
    cmds:
      - task copy:runtimes:from-artifacts TARGET={{.TARGET}}

  build:
    desc: "Build the .NET solution"
    deps:
      - generate
      - copy:runtime:current
    cmds:
      - dotnet build Slim.sln --configuration Release
    silent: true

  test:smoke:
    desc: "Run smoke tests only (no server required)"
    deps:
      - build
    cmds:
      - dotnet test Slim.Tests/Slim.Tests.csproj --configuration Release --filter "FullyQualifiedName~SmokeTests" --verbosity normal
    silent: true

  test:integration:
    desc: "Run integration tests (requires running SLIM server)"
    deps:
      - build
    cmds:
      - echo "WARNING - Make sure SLIM server is running"
      - dotnet test Slim.Tests/Slim.Tests.csproj --configuration Release --filter "FullyQualifiedName~IntegrationTests" --verbosity normal
    silent: true

  test:all:
    desc: "Run all tests (smoke + integration, requires running SLIM server)"
    deps:
      - build
    cmds:
      - echo "WARNING - Make sure SLIM server is running for integration tests"
      - dotnet test Slim.Tests/Slim.Tests.csproj --configuration Release --verbosity normal
    silent: true

  pack:
    desc: "Create NuGet package with all runtime libraries (every major OS and platform)"
    deps:
      - task: build:rust:all
        vars:
          PROFILE: "release"
      - task: generate
    vars:
      VERSION:
        sh: grep '^version = ' ../rust/Cargo.toml | sed 's/version = "\(.*\)"/\1/'
    cmds:
      - task copy:runtimes:from-artifacts
      - dotnet pack Slim/Slim.csproj --configuration Release --output ./nupkg -p:Version={{.VERSION}}
      - echo "Built NuGet package version {{.VERSION}}"
      - ls -lh nupkg/*.nupkg
    silent: true

  publish:
    desc: "Publish NuGet package to NuGet.org"
    deps:
      - pack
    env:
      NUGET_AUTH_TOKEN: "{{.NUGET_API_TOKEN}}"
    cmds:
      - |
        PACKAGE=$(ls nupkg/*.nupkg | head -1)
        echo "Publishing package: $PACKAGE"
        dotnet nuget push "$PACKAGE" \
          --source https://api.nuget.org/v3/index.json \
          --skip-duplicate
        echo "Successfully published to NuGet.org"
    silent: true

  test:verify-package:
    desc: "Verify NuGet package can be installed and works locally"
    deps:
      - pack
    cmds:
      - |
        echo "Verifying NuGet package installation..."
        TEST_DIR=$(mktemp -d)
        trap "rm -rf $TEST_DIR" EXIT
        
        cd "$TEST_DIR"
        echo "Testing in: $TEST_DIR"
        
        # Create a test console application
        dotnet new console -n SlimBindingsTest
        cd SlimBindingsTest
        
        # Add local NuGet source
        NUPKG_PATH="{{.TASKFILE_DIR}}/nupkg"
        dotnet nuget add source "$NUPKG_PATH" --name "LocalPackages"
        
        # Find the package
        PACKAGE=$(ls "$NUPKG_PATH"/*.nupkg | head -1)
        PACKAGE_NAME=$(basename "$PACKAGE" | sed 's/\.[0-9].*//')
        VERSION=$(basename "$PACKAGE" | sed -n 's/.*\.\([0-9][0-9]*\.[0-9][0-9]*\.[0-9][0-9]*.*\)\.nupkg/\1/p')
        
        echo "Package: $PACKAGE_NAME"
        echo "Version: $VERSION"
        
        # Install the package
        dotnet add package "$PACKAGE_NAME" --version "$VERSION" --source "LocalPackages"
        echo "Package installed successfully"
        
        # Copy test program
        cp "{{.TASKFILE_DIR}}/../../.github/tests/dotnet/test_installation.cs" ./Program.cs
        
        # Build and run
        dotnet build
        dotnet run
        
        echo ""
        echo "Package verification complete!"
    silent: true

  ci:
    desc: "Run CI pipeline: generate, build, test, and pack"
    deps:
      - generate
    vars:
      VERSION:
        sh: |
          if [[ -n "{{.VERSION}}" ]]; then
            echo "{{.VERSION}}"
          else
            grep '^version = ' ../rust/Cargo.toml | sed 's/version = "\(.*\)"/\1/'
          fi
    cmds:
      - dotnet build Slim.sln --configuration Release
      - dotnet test Slim.Tests/Slim.Tests.csproj --configuration Release --filter "FullyQualifiedName~SmokeTests" --verbosity normal
      - |
        if [[ -n "{{.ARTIFACTS_DIR}}" ]]; then
          # Copy all runtime libraries from artifacts before packing
          task copy:runtimes:from-artifacts ARTIFACTS_DIR={{.ARTIFACTS_DIR}}
          mkdir -p {{.ARTIFACTS_DIR}}
          dotnet pack Slim/Slim.csproj --configuration Release --output {{.ARTIFACTS_DIR}} -p:Version={{.VERSION}}
          echo "Built NuGet package version {{.VERSION}}"
        fi

  clean:
    desc: "Clean all build artifacts"
    cmds:
      - dotnet clean Slim.sln
      - rm -rf {{.TARGET_DIR}} {{.RUNTIMES_DIR}} {{.GENERATED_DIR}} nupkg/ Slim/bin/ Slim/obj/ Slim.Tests/bin/ Slim.Tests/obj/
    silent: true
