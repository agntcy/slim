# Copyright AGNTCY Contributors (https://github.com/agntcy)
# SPDX-License-Identifier: Apache-2.0

version: "3"

includes:
  adapter:
    taskfile: "../rust/Taskfile.yaml"
    internal: false
  rust:
    taskfile: ../../../tasks/rust.yaml
    internal: true
  tools:
    taskfile: ../../../tasks/tools.yaml
    internal: true
    flatten: true

vars:
  BINDINGS_DIR: "{{.TASKFILE_DIR}}/../rust"
  ##############################################################
  # Vars section does not have acces to importd variables
  # (PROFILE, CURRENT_TARGET, TARGET)
  # so we need to redefine them
  PROFILE: '{{.PROFILE | default "debug"}}'
  CURRENT_TARGET:
    sh: 'rustc -vV | sed -n "s|host: ||p"'
  TARGET: "{{.TARGET | default .CURRENT_TARGET}}"
  ##############################################################
  SERVICE_TARGET:
    sh: echo "{{.TASKFILE_DIR}}/../../target/{{.TARGET}}/{{.PROFILE}}"
  LIB_NAME: slim_bindings
  _DEFAULT_LIB_PATH: "{{.SERVICE_TARGET}}/lib{{.LIB_NAME}}.a"
  LIB_PATH: "{{.LIB_PATH | default ._DEFAULT_LIB_PATH}}"

tasks:
  default:
    cmds:
      - echo {{.TARGET}} {{.SERVICE_TARGET}}
      - task -l

  patch-cgo-directives:
    desc: Patch generated Go bindings with proper cgo directives
    internal: true
    cmds:
      - echo "ðŸ”§ Patching cgo directives..."
      - |
        GO_FILE="slim_bindings/{{.LIB_NAME}}.go"
        if [ -f "$GO_FILE" ]; then
          # Create the new cgo preamble with static LDFLAGS placeholders
          cat > /tmp/cgo_preamble.txt << 'EOF'
        package slim_bindings

        /*
        #cgo CFLAGS: -I${SRCDIR}
        #cgo linux,amd64 LDFLAGS: -L${SRCDIR} -L${SRCDIR}/../../../../../.cgo-cache/slim-bindings -lslim_bindings_x86_64_linux_gnu -lm
        #cgo linux,arm64 LDFLAGS: -L${SRCDIR} -L${SRCDIR}/../../../../../.cgo-cache/slim-bindings -lslim_bindings_aarch64_linux_gnu -lm
        #cgo darwin,amd64 LDFLAGS: -L${SRCDIR} -L${SRCDIR}/../../../../../.cgo-cache/slim-bindings -lslim_bindings_x86_64_darwin -Wl,-undefined,dynamic_lookup
        #cgo darwin,arm64 LDFLAGS: -L${SRCDIR} -L${SRCDIR}/../../../../../.cgo-cache/slim-bindings -lslim_bindings_aarch64_darwin -Wl,-undefined,dynamic_lookup
        #cgo windows,amd64 LDFLAGS: -L${SRCDIR} -L${SRCDIR}/../../../../../.cgo-cache/slim-bindings -lslim_bindings_x86_64_windows_gnu -lws2_32 -lbcrypt -ladvapi32 -luserenv -lntdll -lgcc_eh -lgcc -lkernel32 -lole32
        #include <slim_bindings.h>
        */
        import "C"
        EOF

          # Extract the rest of the file after 'import "C"'
          sed -n '/^import "C"/,$p' "$GO_FILE" | tail -n +2 > /tmp/go_rest.txt

          # Combine the new preamble with the rest of the file
          cat /tmp/cgo_preamble.txt /tmp/go_rest.txt > "$GO_FILE"

          # Cleanup
          rm -f /tmp/cgo_preamble.txt /tmp/go_rest.txt
          echo "âœ… Patched $GO_FILE with cgo directives"
        else
          echo "âš ï¸  Go file not found: $GO_FILE"
          exit 1
        fi
    silent: true

  patch-header:
    desc: Patch slim_bindings.h with Windows dllexport directives
    internal: true
    cmds:
      - echo "ðŸ”§ Patching slim_bindings.h..."
      - |
        HEADER_FILE="slim_bindings/{{.LIB_NAME}}.h"
        if [ -f "$HEADER_FILE" ]; then
          # Check if patch is already applied
          if grep -q "#ifdef _WIN32" "$HEADER_FILE" && grep -q "__declspec(dllexport) void slim_bindings_uniffiFutureContinuationCallback" "$HEADER_FILE"; then
            echo "âœ… Header already patched"
          else
            # Apply the patch: wrap the two function declarations with Windows conditional
            # First, create a temporary file with the patched content
            awk '
              /^void slim_bindings_uniffiFutureContinuationCallback\(uint64_t, int8_t\);$/ {
                print "#ifdef _WIN32"
                print "__declspec(dllexport) void slim_bindings_uniffiFutureContinuationCallback(uint64_t, int8_t);"
                print "__declspec(dllexport) void slim_bindings_uniffiFreeGorutine(uint64_t);"
                print "#else"
                print "void slim_bindings_uniffiFutureContinuationCallback(uint64_t, int8_t);"
                getline
                print "void slim_bindings_uniffiFreeGorutine(uint64_t);"
                print "#endif"
                next
              }
              { print }
            ' "$HEADER_FILE" > "$HEADER_FILE.tmp"
            mv "$HEADER_FILE.tmp" "$HEADER_FILE"
            echo "âœ… Patched $HEADER_FILE with Windows dllexport directives"
          fi
        else
          echo "âš ï¸  Header file not found: $HEADER_FILE"
          exit 1
        fi
    silent: true

  generate:
    desc: Generate Go bindings from compiled library
    deps:
      # bindings:build:all is skipped automatically when the library already
      # exists and sources have not changed (sources/generates fingerprinting).
      - task: adapter:bindings:build:all
      - task: install-uniffi-bindgen-go
    cmds:
      - echo "ðŸ”§ Generating Go bindings from compiled library..."
      - |
        uniffi-bindgen-go \
          --library '{{.LIB_PATH}}' \
          --out-dir '.' \
      - task: copy-library
      - task: patch-header
      - task: patch-cgo-directives
      - echo "âœ… Bindings generated in slim_bindings/"
    silent: true

  generate-from-cache:
    desc: Generate Go bindings using a cached native library
    deps:
      - task: install-uniffi-bindgen-go
    cmds:
      - echo "ðŸ”§ Generating Go bindings from cached library..."
      - |
        set -euo pipefail

        TARGET_OS="{{.TARGETOS}}"
        TARGET_ARCH="{{.TARGETARCH}}"
        TARGET_ABI="{{.TARGETABI}}"

        if [ -z "$TARGET_OS" ]; then
          TARGET_OS="$(go env GOOS)"
        fi
        if [ -z "$TARGET_ARCH" ]; then
          TARGET_ARCH="$(go env GOARCH)"
        fi

        case "$TARGET_OS" in
          darwin)
            if [ "$TARGET_ARCH" = "arm64" ]; then
              LIB_ARCH="aarch64"
            else
              LIB_ARCH="x86_64"
            fi
            LIB_NAME="lib{{.LIB_NAME}}_${LIB_ARCH}_darwin.a"
            ;;
          linux)
            if [ -z "$TARGET_ABI" ]; then
              TARGET_ABI="gnu"
            fi
            if [ "$TARGET_ARCH" = "arm64" ]; then
              LIB_ARCH="aarch64"
            else
              LIB_ARCH="x86_64"
            fi
            LIB_NAME="lib{{.LIB_NAME}}_${LIB_ARCH}_linux_${TARGET_ABI}.a"
            ;;
          windows)
            if [ -z "$TARGET_ABI" ]; then
              TARGET_ABI="gnu"
            fi
            if [ "$TARGET_ARCH" != "amd64" ] && [ "$TARGET_ARCH" != "x86_64" ]; then
              echo "âŒ Unsupported TARGETARCH for windows: $TARGET_ARCH"
              exit 1
            fi
            LIB_NAME="lib{{.LIB_NAME}}_x86_64_windows_${TARGET_ABI}.a"
            ;;
          *)
            echo "âŒ Unsupported TARGETOS: $TARGET_OS"
            exit 1
            ;;
        esac

        GOPATH_DIR=$(go env GOPATH)
        CACHE_DIR="$GOPATH_DIR/.cgo-cache/slim-bindings"
        LIB_PATH="$CACHE_DIR/$LIB_NAME"

        if [ ! -f "$LIB_PATH" ]; then
          echo "âŒ Cached bindings library not found: $LIB_PATH"
          exit 1
        fi

        uniffi-bindgen-go \
          --library "$LIB_PATH" \
          --out-dir '.' \

      - task: patch-header
      - task: patch-cgo-directives
      - echo "âœ… Bindings generated in slim_bindings/"
    silent: true

  install-uniffi-bindgen-go:
    desc: Install uniffi-bindgen-go
    status:
      - which uniffi-bindgen-go
    cmds:
      - echo "ðŸ“¦ Installing uniffi-bindgen-go..."
      - cargo install uniffi-bindgen-go --git https://github.com/agntcy/uniffi-bindgen-go.git --tag v0.4.0+v0.28.3-kegsay --config net.git-fetch-with-cli=true
    silent: true

  copy-library:
    desc: Copy static libraries from all built targets to the generated directory
    internal: true
    cmds:
      - echo "ðŸ“¦ Copying static libraries..."
      - |
        TARGET_BASE=$(dirname "$(dirname "$(dirname '{{.LIB_PATH}}')")")
        DEST_DIR="slim_bindings"
        found_any=false

        # Scan all target/*/{PROFILE}/ directories for static libraries
        for target_release_dir in "$TARGET_BASE"/*/{{.PROFILE}}; do
          [ -d "$target_release_dir" ] || continue

          # Find the static library (Unix: .a, Windows: .lib)
          if [ -f "$target_release_dir/lib{{.LIB_NAME}}.a" ]; then
            lib_file="$target_release_dir/lib{{.LIB_NAME}}.a"
            LIB_EXT="a"
            LIB_PREFIX="lib"
          elif [ -f "$target_release_dir/{{.LIB_NAME}}.lib" ]; then
            lib_file="$target_release_dir/{{.LIB_NAME}}.lib"
            LIB_EXT="lib"
            LIB_PREFIX=""
          else
            continue
          fi

          # Derive platform-specific destination name from the target triple
          target=$(basename "$(dirname "$target_release_dir")")
          ARCH=$(echo "$target" | cut -d'-' -f1)
          OS=$(echo "$target" | cut -d'-' -f3)
          ABI=$(echo "$target" | cut -d'-' -f4)

          if [ -n "$ABI" ] && [ "$ABI" != "" ]; then
            DEST_NAME="${LIB_PREFIX}{{.LIB_NAME}}_${ARCH}_${OS}_${ABI}.${LIB_EXT}"
          else
            DEST_NAME="${LIB_PREFIX}{{.LIB_NAME}}_${ARCH}_${OS}.${LIB_EXT}"
          fi

          file_size=$(stat -f%z "$lib_file" 2>/dev/null || stat -c%s "$lib_file" 2>/dev/null)
          echo "   $target â†’ $DEST_NAME ($((file_size / 1024 / 1024))MB)"
          cp "$lib_file" "$DEST_DIR/$DEST_NAME"
          found_any=true
        done

        if [ "$found_any" = false ]; then
          echo "âš ï¸  No static libraries found under $TARGET_BASE"
          exit 1
        fi
      - echo "âœ… Libraries in slim_bindings/:"
      - ls -lah "slim_bindings/"*{{.LIB_NAME}}*.a "slim_bindings/"*{{.LIB_NAME}}*.lib 2>/dev/null || echo "  (no library files found)"
    silent: true

  generate-proto:
    desc: "Generate proto files for the Python bindings"
    deps:
      - task: rust:toolchain:run-command
        vars:
          COMMAND: |
            cargo build --package agntcy-protoc-slimrpc-plugin --bin protoc-gen-slimrpc-go --release
      - task: tools:buf
    cmds:
      - |
        # Find all the buf.gen.yaml files in the current directory and its subdirectories
        find . -name 'buf.gen.yaml' | while read -r file; do
          # Generate the proto files using buf
          echo "Generating proto files for $file"
          # get folder name
          folder=$(dirname "$file")
          pushd > /dev/null ${folder} && {{.TOOLS_INSTALL_DIR}}/buf generate && popd > /dev/null
        done

  test:
    desc: Run all tests
    deps:
      - task: generate
    cmds:
      - echo "ðŸ§ª Running all tests..."
      - go test -v ./...
      - echo "âœ… All Go tests passed"
    silent: true

  test-coverage:
    desc: Run tests with coverage report
    deps:
      - task: adapter:bindings:build:all
        vars:
          PROFILE: release
    cmds:
      - echo "ðŸ“Š Running tests with coverage..."
      - go test -v -coverprofile=coverage.out ./...
      - go tool cover -html=coverage.out -o coverage.html
      - echo "âœ… Coverage report generated in coverage.html"
    silent: true

  clean:
    desc: Clean build artifacts
    cmds:
      - echo "ðŸ§¹ Cleaning build artifacts..."
      - cd {{.BINDINGS_DIR}} && cargo clean
      - rm slim_bindings/slim_bindings.go || true
      - rm slim_bindings/slim_bindings.h || true
      - rm slim_bindings/libslim_bindings_*.a || true
      - echo "âœ… Clean complete"
    silent: true

  # Examples
  example:server:
    desc: Run the SLIM server
    deps:
      - task: adapter:bindings:build:all
        vars:
          PROFILE: release
    dir: examples/server
    cmds:
      - echo "ðŸš€ Starting SLIM server..."
      - go run . {{.CLI_ARGS}}
    silent: true

  example:p2p:alice:
    desc: Run Alice (receiver) for point-to-point example
    deps:
      - task: adapter:bindings:build:all
        vars:
          PROFILE: release
    dir: examples/point_to_point
    cmds:
      - echo "ðŸ‘© Starting Alice (receiver)..."
      - go run . --local="org/alice/app" --server="http://localhost:46357" {{.CLI_ARGS}}
    silent: true

  example:p2p:no-mls:bob:
    desc: Run Bob (sender) for point-to-point example
    deps:
      - task: adapter:bindings:build:all
        vars:
          PROFILE: release
    dir: examples/point_to_point
    cmds:
      - echo "ðŸ‘¨ Starting Bob (sender)..."
      - go run . --local="org/bob/app" --remote="org/alice/app" --message="Hello SLIM" --iterations=5 --server="http://localhost:46357" {{.CLI_ARGS}}
    silent: true

  example:p2p:mls:bob:
    desc: Run Bob (sender) for point-to-point example
    deps:
      - task: adapter:bindings:build:all
        vars:
          PROFILE: release
    dir: examples/point_to_point
    cmds:
      - echo "ðŸ‘¨ Starting Bob (sender)..."
      - go run . --enable-mls --local="org/bob/app" --remote="org/alice/app" --message="Hello SLIM" --iterations=5 --server="http://localhost:46357" {{.CLI_ARGS}}
    silent: true

  example:group:moderator:
    desc: Run group moderator (creates session and invites participants)
    deps:
      - task: adapter:bindings:build:all
        vars:
          PROFILE: release
    dir: examples/group
    cmds:
      - echo "ðŸ‘‘ Starting group moderator..."
      - go run . --local="org/moderator/app" --remote="org/default/chat-room" --invites="org/alice/app,org/bob/app" --server="http://localhost:46357" {{.CLI_ARGS}}
    silent: true

  example:group:participant:alice:
    desc: Run group participant (waits for invitation)
    deps:
      - task: adapter:bindings:build:all
        vars:
          PROFILE: release
    dir: examples/group
    cmds:
      - echo "ðŸ‘¤ Starting group participant..."
      - go run . --local="org/alice/app" --server="http://localhost:46357" {{.CLI_ARGS}}
    silent: true

  example:group:participant:bob:
    desc: Run group participant (waits for invitation)
    deps:
      - task: adapter:bindings:build:all
        vars:
          PROFILE: release
    dir: examples/group
    cmds:
      - echo "ðŸ‘¤ Starting group participant..."
      - go run . --local="org/bob/app" --server="http://localhost:46357" {{.CLI_ARGS}}
    silent: true
