# Copyright AGNTCY Contributors (https://github.com/agntcy)
# SPDX-License-Identifier: Apache-2.0

version: '3'

includes:
  adapter:
    taskfile: "../adapter/Taskfile.yaml"
    internal: true
  rust:
    taskfile: ../../../tasks/rust.yaml
    internal: true

vars:
  # The Rust UniFFI bindings crate - in bindings/adapter (sibling to bindings/go)
  BINDINGS_DIR: "{{.TASKFILE_DIR}}../adapter"
  SERVICE_TARGET: "{{.TASKFILE_DIR}}/../../target/release"
  LIB_NAME: slim_bindings
  _DEFAULT_LIB_PATH: "{{.SERVICE_TARGET}}/lib{{.LIB_NAME}}.a"
  LIB_PATH: "{{.LIB_PATH | default ._DEFAULT_LIB_PATH}}"

tasks:
  default:
    cmds:
      - task -l

  rust-build:
    desc: Build the Rust library with UniFFI (release mode)
    dir: "{{.BINDINGS_DIR}}"
    cmds:
      - echo "ðŸ¦€ Building Rust bindings library with UniFFI (release mode)..."
      - cargo build --release
    silent: true

  ensure-lib:
    desc: Ensure the UniFFI library is built
    cmds:
      - |
        if [ ! -f "{{.LIB_PATH}}" ]; then
          echo "âš ï¸  UniFFI library not found, building now..."
          task rust-build
        else
          echo "âœ… Found UniFFI library: {{.LIB_PATH}}"
        fi
    silent: true

  patch-cgo-directives:
    desc: Patch generated Go bindings with proper cgo directives
    internal: true
    cmds:
      - echo "ðŸ”§ Patching cgo directives..."
      - |
        GO_FILE="generated/{{.LIB_NAME}}/{{.LIB_NAME}}.go"
        if [ -f "$GO_FILE" ]; then
          # Build LDFLAGS dynamically based on available library files
          DEST_DIR="generated/{{.LIB_NAME}}"
          
          # Create the new cgo preamble with dynamic library lists
          cat > /tmp/cgo_preamble.txt << 'EOF'
        package slim_bindings

        /*
        #cgo CFLAGS: -I${SRCDIR}
        EOF
          
          # Add LDFLAGS for each platform dynamically
          echo "ðŸ” Scanning for libraries in generated/{{.LIB_NAME}}/"
          
          # linux amd64 gnu (x86_64)
          LIBS=""
          for lib in generated/{{.LIB_NAME}}/libslim_bindings_x86_64_linux_gnu*.a; do
            if [ -f "$lib" ]; then
              echo "   Found: $(basename $lib)"
              LIBS="$LIBS \${SRCDIR}/$(basename $lib)"
            fi
          done
          if [ -n "$LIBS" ]; then
            echo "   Adding linux,amd64 (gnu) LDFLAGS with $(echo $LIBS | wc -w) libraries"
            echo "#cgo linux,amd64 LDFLAGS: -Wl,--start-group$LIBS -Wl,--end-group -lm" >> /tmp/cgo_preamble.txt
          fi
          

          # linux arm64 gnu (aarch64)
          LIBS=""
          for lib in generated/{{.LIB_NAME}}/libslim_bindings_aarch64_linux_gnu*.a; do
            if [ -f "$lib" ]; then
              LIBS="$LIBS \${SRCDIR}/$(basename $lib)"
            fi
          done
          if [ -n "$LIBS" ]; then
            echo "#cgo linux,arm64 LDFLAGS: -Wl,--start-group$LIBS -Wl,--end-group -lm" >> /tmp/cgo_preamble.txt
          fi
          

          # darwin amd64 (x86_64)
          LIBS=""
          for lib in generated/{{.LIB_NAME}}/libslim_bindings_x86_64_darwin*.a; do
            if [ -f "$lib" ]; then
              LIBS="$LIBS \${SRCDIR}/$(basename $lib)"
            fi
          done
          if [ -n "$LIBS" ]; then
            echo "#cgo darwin,amd64 LDFLAGS:$LIBS$LIBS -Wl,-undefined,dynamic_lookup" >> /tmp/cgo_preamble.txt
          fi
          
          # darwin arm64 (aarch64)
          LIBS=""
          for lib in generated/{{.LIB_NAME}}/libslim_bindings_aarch64_darwin*.a; do
            if [ -f "$lib" ]; then
              LIBS="$LIBS \${SRCDIR}/$(basename $lib)"
            fi
          done
          if [ -n "$LIBS" ]; then
            echo "#cgo darwin,arm64 LDFLAGS:$LIBS$LIBS -Wl,-undefined,dynamic_lookup" >> /tmp/cgo_preamble.txt
          fi
          
          # windows amd64 (x86_64)
          LIBS=""
          for lib in generated/{{.LIB_NAME}}/libslim_bindings_x86_64_windows*.a; do
            if [ -f "$lib" ]; then
              LIBS="$LIBS \${SRCDIR}/$(basename $lib)"
            fi
          done
          if [ -n "$LIBS" ]; then
            echo "#cgo windows,amd64 LDFLAGS:$LIBS$LIBS" >> /tmp/cgo_preamble.txt
          fi
          
          # windows arm64 (aarch64)
          LIBS=""
          for lib in generated/{{.LIB_NAME}}/libslim_bindings_aarch64_windows*.a; do
            if [ -f "$lib" ]; then
              LIBS="$LIBS \${SRCDIR}/$(basename $lib)"
            fi
          done
          if [ -n "$LIBS" ]; then
            echo "#cgo windows,arm64 LDFLAGS:$LIBS$LIBS" >> /tmp/cgo_preamble.txt
          fi
          
          cat >> /tmp/cgo_preamble.txt << 'EOF'
        #include <slim_bindings.h>
        */
        import "C"
        EOF

          # Extract the rest of the file after 'import "C"'
          sed -n '/^import "C"/,$p' "$GO_FILE" | tail -n +2 > /tmp/go_rest.txt

          # Combine the new preamble with the rest of the file
          cat /tmp/cgo_preamble.txt /tmp/go_rest.txt > "$GO_FILE"

          # Cleanup
          rm -f /tmp/cgo_preamble.txt /tmp/go_rest.txt
          echo "âœ… Patched $GO_FILE with dynamic cgo directives"
        else
          echo "âš ï¸  Go file not found: $GO_FILE"
          exit 1
        fi
    silent: true

  copy-library:
    desc: Copy shared library to generated directory
    internal: true
    cmds:
      - echo "ðŸ“¦ Copying static libraries..."
      - |
        LIB_DIR=$(dirname "{{.LIB_PATH}}")
        DEST_DIR="generated/{{.LIB_NAME}}"
        MAX_SIZE=$((100 * 1024 * 1024))  # 100 MB in bytes
        
        # Function to split a .a archive into smaller .a archives using rust-ar
        split_archive() {
          local src_file="$1"
          local base_name="$2"
          
          local file_size=$(stat -f%z "$src_file" 2>/dev/null || stat -c%s "$src_file" 2>/dev/null)
          echo "âš ï¸  Library is ${file_size} bytes (>100MB), splitting archive..."
          
          # Convert to absolute path before changing directory
          local abs_src_file=$(cd "$(dirname "$src_file")" && pwd)/$(basename "$src_file")
          local abs_dest_dir=$(cd "$DEST_DIR" && pwd)
          
          # Save original directory
          local orig_dir=$(pwd)
          
          # Create temp directory for extraction
          local temp_dir=$(mktemp -d)
          
          cd "$temp_dir"
          
          # Extract all objects from the archive using rust-ar
          rust-ar x "$abs_src_file"
          
          # Get list of object files and their sizes
          local objects=(*.o)
          local total_objects=${#objects[@]}
          
          echo "   Extracted $total_objects object files from archive"
          
          # Target size per archive (50MB)
          local target_size=$((50 * 1024 * 1024))
          
          # Split objects into archives based on cumulative size
          local part_num=0
          local current_size=0
          local current_objects=()
          
          for obj in "${objects[@]}"; do
            local obj_size=$(stat -f%z "$obj" 2>/dev/null || stat -c%s "$obj" 2>/dev/null)
            
            # If adding this object would exceed target, create archive (unless it's the first object)
            if [ ${#current_objects[@]} -gt 0 ] && [ $((current_size + obj_size)) -gt $target_size ]; then
              part_name="${base_name}_part${part_num}.a"
              rust-ar rcs "$abs_dest_dir/$part_name" "${current_objects[@]}"
              local part_size=$(stat -f%z "$abs_dest_dir/$part_name" 2>/dev/null || stat -c%s "$abs_dest_dir/$part_name" 2>/dev/null)
              echo "   Created $part_name with ${#current_objects[@]} objects (~$((part_size / 1024 / 1024))MB)"
              
              current_objects=()
              current_size=0
              part_num=$((part_num + 1))
            fi
            
            current_objects+=("$obj")
            current_size=$((current_size + obj_size))
          done
          
          # Create final archive with remaining objects
          if [ ${#current_objects[@]} -gt 0 ]; then
            part_name="${base_name}_part${part_num}.a"
            rust-ar rcs "$abs_dest_dir/$part_name" "${current_objects[@]}"
            local part_size=$(stat -f%z "$abs_dest_dir/$part_name" 2>/dev/null || stat -c%s "$abs_dest_dir/$part_name" 2>/dev/null)
            echo "   Created $part_name with ${#current_objects[@]} objects (~$((part_size / 1024 / 1024))MB)"
          fi
          
          # Verify all objects were included
          local total_in_parts=0
          for ((i=0; i<=part_num; i++)); do
            if [ -f "$abs_dest_dir/${base_name}_part${i}.a" ]; then
              local count=$(rust-ar t "$abs_dest_dir/${base_name}_part${i}.a" 2>/dev/null | wc -l)
              total_in_parts=$((total_in_parts + count))
            fi
          done
          
          if [ $total_in_parts -ne $total_objects ]; then
            echo "   âš ï¸  WARNING: Object count mismatch! Original: $total_objects, In parts: $total_in_parts"
          else
            echo "   âœ… Verified: All $total_objects objects included in split archives"
          fi
          
          # Return to original directory before cleanup
          cd "$orig_dir"
          rm -rf "$temp_dir"
        }
        
        # Function to process a library file (copy or split if too large)
        process_library() {
          local src_file="$1"
          local dest_file="$2"
          local file_size=$(stat -f%z "$src_file" 2>/dev/null || stat -c%s "$src_file" 2>/dev/null)
          
          if [ "$file_size" -gt "$MAX_SIZE" ]; then
            local base_name=$(basename "$dest_file" .a)
            split_archive "$src_file" "$base_name"
          else
            echo "   Copying $(basename $dest_file) ($((file_size / 1024 / 1024))MB)"
            cp "$src_file" "$dest_file"
          fi
        }
        
        # Check if libraries already have platform-specific names (from CI build)
        PLATFORM_LIBS=$(find "$LIB_DIR" -type f -name "lib{{.LIB_NAME}}_*.a" 2>/dev/null | head -1)
        
        if [ -n "$PLATFORM_LIBS" ]; then
          # CI build: libraries already have platform-specific names
          echo "ðŸ“¦ Found platform-specific libraries, processing..."
          find "$LIB_DIR" -type f -name "lib{{.LIB_NAME}}_*.a" | while read -r lib_file; do
            dest_name=$(basename "$lib_file")
            process_library "$lib_file" "$DEST_DIR/$dest_name"
          done
        else
          # Local build: need to detect platform and rename
          echo "ðŸ“¦ Local build detected, renaming library for current platform..."
          
          # Detect architecture
          ARCH=$(uname -m)
          case "$ARCH" in
            x86_64|amd64) ARCH="x86_64" ;;
            arm64|aarch64) ARCH="aarch64" ;;
          esac
          
          # Detect OS
          OS=$(uname -s | tr '[:upper:]' '[:lower:]')
          case "$OS" in
            darwin) OS="darwin" ;;
            linux) OS="linux_gnu" ;;  # Assume GNU for local builds
          esac
          
          LIB_NAME="lib{{.LIB_NAME}}_${ARCH}_${OS}"
          
          if [ -f "{{.LIB_PATH}}" ]; then
            process_library "{{.LIB_PATH}}" "$DEST_DIR/${LIB_NAME}.a"
            echo "âœ… Processed {{.LIB_PATH}} -> $DEST_DIR/$LIB_NAME"
          else
            echo "âš ï¸  Library not found: {{.LIB_PATH}}"
            exit 1
          fi
        fi
      - echo "âœ… Libraries in generated/{{.LIB_NAME}}/:"
      - ls -lah "generated/{{.LIB_NAME}}/"*{{.LIB_NAME}}*.a 2>/dev/null || echo "  (no .a files found)"
    silent: true

  generate:
    desc: Generate Go bindings from compiled library
    deps:
      - ensure-lib
      - install-uniffi-bindgen-go
      - install-rust-ar
    cmds:
      - echo "ðŸ”§ Generating Go bindings from compiled library..."
      - |
        uniffi-bindgen-go \
          --library '{{.LIB_PATH}}' \
          --library '{{.LIB_PATH}}' \
          --out-dir generated
      - cd generated && go mod init github.com/agntcy/slim/bindings/generated 2>/dev/null || true
      - task: copy-library
      - task: patch-cgo-directives
      - echo "âœ… Bindings generated in generated/"
    silent: true

  install-uniffi-bindgen-go:
    desc: Install uniffi-bindgen-go
    status:
      - which uniffi-bindgen-go
    status:
      - which uniffi-bindgen-go
    cmds:
      - echo "ðŸ“¦ Installing uniffi-bindgen-go..."
      - echo "ðŸ“¦ Installing uniffi-bindgen-go..."
      - cargo install uniffi-bindgen-go --git https://github.com/NordSecurity/uniffi-bindgen-go.git --tag v0.4.0+v0.28.3 --config net.git-fetch-with-cli=true
    silent: true
    
  install-rust-ar:
    desc: Install rust-ar (cargo-ar)
    status:
      - which rust-ar
    cmds:
      - echo "ðŸ“¦ Installing rust-ar..."
      - cargo install cargo-binutils
    silent: true

  test:
    desc: Run all tests
    deps: [ensure-lib]
    cmds:
      - echo "ðŸ§ª Running all tests..."
      - go test -v ./...
      - echo "âœ… All Go tests passed"
    silent: true

  test-coverage:
    desc: Run tests with coverage report
    deps: [ensure-lib]
    cmds:
      - echo "ðŸ“Š Running tests with coverage..."
      - go test -v -coverprofile=coverage.out ./...
      - go tool cover -html=coverage.out -o coverage.html
      - echo "âœ… Coverage report generated in coverage.html"
    silent: true

  clean:
    desc: Clean build artifacts
    cmds:
      - echo "ðŸ§¹ Cleaning build artifacts..."
      - cd {{.BINDINGS_DIR}} && cargo clean
      - rm -rf generated/
      - echo "âœ… Clean complete"
    silent: true

  # Examples
  example:
    desc: Run the simple example
    deps:
      - task: adapter:bindings:build:all
        vars:
          PROFILE: release
    dir: examples/simple
    cmds:
      - echo "ðŸš€ Running simple example..."
      - go run .
    silent: true

  example:server:
    desc: Run the SLIM server
    deps:
      - task: adapter:bindings:build:all
        vars:
          PROFILE: release
    dir: cmd/server
    cmds:
      - echo "ðŸš€ Starting SLIM server..."
      - go run . {{.CLI_ARGS}}
    silent: true

  example:p2p:alice:
    desc: Run Alice (receiver) for point-to-point example
    deps:
      - task: adapter:bindings:build:all
        vars:
          PROFILE: release
    dir: examples/point_to_point
    cmds:
      - echo "ðŸ‘© Starting Alice (receiver)..."
      - go run . --local="org/alice/app" --server="http://localhost:46357" {{.CLI_ARGS}}
    silent: true

  example:p2p:bob:
    desc: Run Bob (sender) for point-to-point example
    deps:
      - task: adapter:bindings:build:all
        vars:
          PROFILE: release
    dir: examples/point_to_point
    cmds:
      - echo "ðŸ‘¨ Starting Bob (sender)..."
      - go run . --local="org/bob/app" --remote="org/alice/app" --message="Hello SLIM" --iterations=5 --server="http://localhost:46357" {{.CLI_ARGS}}
    silent: true

  example:group:moderator:
    desc: Run group moderator (creates session and invites participants)
    deps:
      - task: adapter:bindings:build:all
        vars:
          PROFILE: release
    dir: examples/group
    cmds:
      - echo "ðŸ‘‘ Starting group moderator..."
      - go run . --local="org/moderator/app" --remote="org/default/chat-room" --invites="org/alice/app,org/bob/app" --server="http://localhost:46357" {{.CLI_ARGS}}
    silent: true

  example:group:participant:alice:
    desc: Run group participant (waits for invitation)
    deps:
      - task: adapter:bindings:build:all
        vars:
          PROFILE: release
    dir: examples/group
    cmds:
      - echo "ðŸ‘¤ Starting group participant..."
      - go run . --local="org/alice/app" --server="http://localhost:46357" {{.CLI_ARGS}}
    silent: true

  example:group:participant:bob:
    desc: Run group participant (waits for invitation)
    deps:
      - task: adapter:bindings:build:all
        vars:
          PROFILE: release
    dir: examples/group
    cmds:
      - echo "ðŸ‘¤ Starting group participant..."
      - go run . --local="org/bob/app" --server="http://localhost:46357" {{.CLI_ARGS}}
    silent: true
