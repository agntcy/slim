# SRPC (SLIM Remote Procedure Call)

SRPC, or SLIM Remote Procedure Call, is a mechanism designed to enable Protocol Buffers (protobuf) RPC over SLIM (Secure Low-latency Inter-process Messaging). This is analogous to gRPC, which leverages HTTP/2 as its underlying transport layer for protobuf RPC.

A key advantage of SRPC lies in its ability to seamlessly integrate SLIM as the transport protocol for inter-application message exchange. This significantly simplifies development: a protobuf file can be compiled to generate code that utilizes SLIM for communication. Application developers can then interact with the generated code much like they would with standard gRPC, while benefiting from the inherent security features and efficiency provided by the SLIM protocol.

This README provides a guide to understanding how SRPC functions and how you can implement it in your applications. For detailed instructions on compiling a protobuf file to obtain the necessary SRPC stub code, please refer to the dedicated README file of the SRPC compiler (TODO).

## SLIM naming in SRPC

In SRPC, each service and its individual RPC handlers are assigned a SLIM name, facilitating efficient message routing and processing. Consider the example protobuf definition located in ```srpc/examples/simple```, which defines four distinct services:
```
syntax = "proto3";

package example_service;

service Test {
  rpc ExampleUnaryUnary(ExampleRequest) returns (ExampleResponse);
  rpc ExampleUnaryStream(ExampleRequest) returns (stream ExampleResponse);
  rpc ExampleStreamUnary(stream ExampleRequest) returns (ExampleResponse);
  rpc ExampleStreamStream(stream ExampleRequest) returns (stream ExampleResponse);
}
```

This example showcases the four primary communication patterns supported by gRPC: Unary-Unary, Unary-Stream, Stream-Unary, and Stream-Stream.

For SRPC, a specific SLIM name is generated for each handler within a service. This naming convention allows an application exposing the service to precisely listen for and process messages intended for a particular RPC method. The format for these names is:

{package-name}.{service-name}-{handler_name}

Based on the example_service.Test definition, the names for each handler would be:
```
example_service.Test-ExampleUnaryUnary
example_service.Test-ExampleUnaryStream
example_service.Test-ExampleStreamUnary
example_service.Test-ExampleStreamStream
```

This handler name is appended to the second component of the SLIM name associated with the running application. For instance, to receive messages for ```example_service.Test-ExampleUnaryUnary```, an applicatin would subscribe to:
```
component[0]/component[1]/component[2]-example_service.Test-ExampleUnaryUnary/component[3]
```

The subscription process is entirely managed by the SRPC package. Application developers are not required to explicitly handle SLIM name subscriptions. Instead, they only need to implement the specific functions that will be invoked when a message arrives for a defined RPC method.

## Example

This section provides a detailed walkthrough of a basic SRPC client-server interaction, leveraging the simple example provided in ```srpc/examples/simple```.

### Generated Code
The foundation of this example is the ```example.proto``` file, which is a standard Protocol Buffers definition file. This file is compiled using the SRPC compiler (refer to the [SRPC Compiler README] for installation and usage instructions) to generate the necessary Python stub code. The generated code is available in two files: ```example_pb2.py``` and ```example_pb2_srpc.py```.
Specifically, ```example_pb2_srpc.py``` contains the SRPC-specific stubs for both client and server implementations. Below are the key classes and functions generated by the compiler:

*Client Stub (TestStub)*:
The TestStub class represents the client-side interface for interacting with the Test service. It provides methods for each RPC defined in example.proto, allowing clients to initiate calls to the server.

```
class TestStub:
    """Client stub for Test."""
    def __init__(self, channel):
        """Constructor.

        Args:
            channel: A srpc.Channel.
        """
        self.ExampleUnaryUnary = channel.unary_unary(
            "/example_service.Test/ExampleUnaryUnary",
            request_serializer=pb2.ExampleRequest.SerializeToString,
            response_deserializer=pb2.ExampleResponse.FromString,
        )
        self.ExampleUnaryStream = channel.unary_stream(
            "/example_service.Test/ExampleUnaryStream",
            request_serializer=pb2.ExampleRequest.SerializeToString,
            response_deserializer=pb2.ExampleResponse.FromString,
        )
        self.ExampleStreamUnary = channel.stream_unary(
            "/example_service.Test/ExampleStreamUnary",
            request_serializer=pb2.ExampleRequest.SerializeToString,
            response_deserializer=pb2.ExampleResponse.FromString,
        )
        self.ExampleStreamStream = channel.stream_stream(
            "/example_service.Test/ExampleStreamStream",
            request_serializer=pb2.ExampleRequest.SerializeToString,
            response_deserializer=pb2.ExampleResponse.FromString,
        )
````

*Server Servicer (TestServicer)*:
The TestServicer class defines the server-side interface. Developers implement this class to provide the actual business logic for each RPC method.
```
class TestServicer():
    """Server servicer for Test. Implement this class to provide your service logic."""

    def ExampleUnaryUnary(self, request, context):
        """Method for ExampleUnaryUnary. Implement your service logic here."""
        raise srpc_rpc.SRPCResponseError(
            code=code__pb2.UNIMPLEMENTED, message="Method not implemented!"
        )
    def ExampleUnaryStream(self, request, context):
        """Method for ExampleUnaryStream. Implement your service logic here."""
        raise srpc_rpc.SRPCResponseError(
            code=code__pb2.UNIMPLEMENTED, message="Method not implemented!"
        )
    def ExampleStreamUnary(self, request_iterator, context):
        """Method for ExampleStreamUnary. Implement your service logic here."""
        raise srpc_rpc.SRPCResponseError(
            code=code__pb2.UNIMPLEMENTED, message="Method not implemented!"
        )
    def ExampleStreamStream(self, request_iterator, context):
        """Method for ExampleStreamStream. Implement your service logic here."""
        raise srpc_rpc.SRPCResponseError(
            code=code__pb2.UNIMPLEMENTED, message="Method not implemented!"
        )
```
*Server Registration Function (add_TestServicer_to_server)*:
This utility function registers an implemented TestServicer instance with an SRPC server. It maps RPC method names to their corresponding handlers and specifies the request deserialization and response serialization routines.

```
def add_TestServicer_to_server(servicer, server: srpc.Server):
    rpc_method_handlers = {
        "ExampleUnaryUnary": srpc.unary_unary_rpc_method_handler(
            behaviour=servicer.ExampleUnaryUnary,
            request_deserializer=pb2.ExampleRequest.FromString,
            response_serializer=pb2.ExampleResponse.SerializeToString,
        ),
        "ExampleUnaryStream": srpc.unary_stream_rpc_method_handler(
            behaviour=servicer.ExampleUnaryStream,
            request_deserializer=pb2.ExampleRequest.FromString,
            response_serializer=pb2.ExampleResponse.SerializeToString,
        ),
        "ExampleStreamUnary": srpc.stream_unary_rpc_method_handler(
            behaviour=servicer.ExampleStreamUnary,
            request_deserializer=pb2.ExampleRequest.FromString,
            response_serializer=pb2.ExampleResponse.SerializeToString,
        ),
        "ExampleStreamStream": srpc.stream_stream_rpc_method_handler(
            behaviour=servicer.ExampleStreamStream,
            request_deserializer=pb2.ExampleRequest.FromString,
            response_serializer=pb2.ExampleResponse.SerializeToString,
        ),

    }

    server.register_method_handlers(
        "example_service.Test",
        rpc_method_handlers,
    )
```

### Server implementation
The server-side logic is defined in ```server.py```. Similar to standard gRPC implementations, the core service functionality is provided by the TestService class, which inherits from TestServicer (as introduced in the previous section). This class contains the concrete implementations for each of the defined RPC methods.

The SLIM-specific code and configuration is handled within the amain() asynchronous function. This function utilizes the create_server helper to instantiate an SRPC server:
```
def create_server(
    local: str,
    slim: dict,
    enable_opentelemetry: bool = False,
    shared_secret: str = "",
) -> Server:
    """
    Create a new SRPC server instance.
    """
    server = Server(
        local=local,
        slim=slim,
        enable_opentelemetry=enable_opentelemetry,
        shared_secret=shared_secret,
    )

    return server


async def amain() -> None:
    server = create_server(
        local="agntcy/grpc/server",
        slim={
            "endpoint": "http://localhost:46357",
            "tls": {
                "insecure": True,
            },
        },
        enable_opentelemetry=False,
        shared_secret="my_shared_secret",
    )

    # Create RPCs
    add_TestServicer_to_server(
        TestService(),
        server,
    )

    await server.run()
```

A new server application is created using the ```create_server``` function. The local parameter, set to "agntcy/grpc/server", assigns a SLIM name to this server application. 
This name is then used to construct the full SLIM RPC names for each method:
```
agntcy/grpc/server-example_service.Test-ExampleUnaryUnary
agntcy/grpc/server-example_service.Test-ExampleUnaryStream
agntcy/grpc/server-example_service.Test-ExampleStreamUnary
agntcy/grpc/server-example_service.Test-ExampleStreamStream
```
Additionally, the ```slim``` dictionary configures the server to connect to a SLIM node running at ```http://localhost:46357```. The tls setting ```insecure: True``` disables TLS for simplicity in this example. 
The ```shared_secret``` parameter is used for initializing the Message Layer Security (MLS) protocol. Note that using a hardcoded shared_secret like "my_shared_secret" is not recommended, please refer to the documentation 
for proper MLS configuration.

Finally, the add_TestServicer_to_server function is called to register the implemented TestService with the SRPC server, making its RPC methods available.
```
    # Create RPCs
    add_TestServicer_to_server(
        TestService(),
        server,
    )
```

### Client implementation
The client-side implementation, found in client.py, largely mirrors the structure of a standard gRPC client. The primary distinction and SLIM-specific aspect lies in the creation of the SRPC channel:
```
    channel = srpc.Channel(
        local="agntcy/grpc/client",
        slim={
            "endpoint": "http://localhost:46357",
            "tls": {
                "insecure": True,
            },
        },
        enable_opentelemetry=False,
        shared_secret="my_shared_secret",
        remote="agntcy/grpc/server",
    )
```

As for the server case the ```local``` parameter, set to ```agntcy/grpc/client```, assigns a SLIM name to the client application. This results in the client's internal RPC handlers being named:
```
agntcy/grpc/client-example_service.Test-ExampleUnaryUnary
agntcy/grpc/client-example_service.Test-ExampleUnaryStream
agntcy/grpc/client-example_service.Test-ExampleStreamUnary
agntcy/grpc/client-example_service.Test-ExampleStreamStream
```
Also, like in the case of the server application, the ```slim``` dictionary specifies the SLIM node endpoint (http://localhost:46357) and TLS settings, consistent with the server's configuration, while
```shared_secret``` initialize MLS to match the server setup.
The remote parameter, set to "agntcy/grpc/server", explicitly identifies the SLIM name of the target server application. This allows the SRPC channel to correctly route messages to the appropriate server endpoint within the SLIM network.

### Run the example
To run the example ...
TODO. add Task command for this 



