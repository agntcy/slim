// Copyright AGNTCY Contributors (https://github.com/agntcy)
// SPDX-License-Identifier: Apache-2.0

use anyhow::{Context, Result};
use heck::ToSnakeCase;
use prost::Message;
use prost_types::compiler::{
    CodeGeneratorRequest, CodeGeneratorResponse, code_generator_response::File,
};
use std::collections::{HashMap, HashSet};
use std::io::{self, Read, Write};

/// Supported parameters for the code generator plugin.
const TYPES_IMPORT: &str = "types_import";

// --- TEMPLATE DEFINITIONS ---

const FILE_TEMPLATE: &str = r#"# Generated by protoc-slimrpc-plugin
# This file is generated from an embedded template. Do not edit directly.

import slimrpc
from slimrpc import rpc as slimrpc_rpc

from google.rpc import code_pb2 as code__pb2

{{PB2_IMPORTS}}

{{SERVICE_DEFINITIONS}}

{{ADD_SERVICER_FUNCTIONS}}
"#;

const SERVICE_STUB_TEMPLATE: &str = r#"
class {{SERVICE_NAME}}Stub:
    """Client stub for {{SERVICE_NAME}}."""
    def __init__(self, channel):
        """Constructor.

        Args:
            channel: A slimrpc.Channel.
        """
{{METHOD_STUB_INITIALIZERS}}
"#;

const METHOD_STUB_INITIALIZER_TEMPLATE: &str = r#"        self.{{METHOD_NAME}} = channel.{{RPC_TYPE}}(
            "/{{PACKAGE_NAME}}.{{SERVICE_NAME}}/{{METHOD_NAME}}",
            request_serializer={{INPUT_TYPE_FULL_PATH}}.SerializeToString,
            response_deserializer={{OUTPUT_TYPE_FULL_PATH}}.FromString,
        )
"#;

const SERVICE_SERVICER_TEMPLATE: &str = r#"
class {{SERVICE_NAME}}Servicer():
    """Server servicer for {{SERVICE_NAME}}. Implement this class to provide your service logic."""

{{METHOD_SERVICERS}}
"#;

const METHOD_SERVICER_TEMPLATE: &str = r#"    def {{METHOD_NAME}}(self, {{REQUEST_ARG}}, context):
        """Method for {{METHOD_NAME}}. Implement your service logic here."""
        raise slimrpc_rpc.SRPCResponseError(
            code=code__pb2.UNIMPLEMENTED, message="Method not implemented!"
        )
"#;

const ADD_SERVICER_FUNCTION_TEMPLATE: &str = r#"
def add_{{SERVICE_NAME}}Servicer_to_server(servicer, server: slimrpc.Server):
    rpc_method_handlers = {
{{RPC_METHOD_HANDLERS}}
    }

    server.register_method_handlers(
        "{{PACKAGE_NAME}}.{{SERVICE_NAME}}",
        rpc_method_handlers,
    )
"#;

const RPC_METHOD_HANDLER_TEMPLATE: &str = r#"        "{{METHOD_NAME}}": slimrpc.{{RPC_TYPE}}_rpc_method_handler(
            behaviour=servicer.{{METHOD_NAME}},
            request_deserializer={{INPUT_TYPE_FULL_PATH}}.FromString,
            response_serializer={{OUTPUT_TYPE_FULL_PATH}}.SerializeToString,
        ),
"#;

// --- END TEMPLATE DEFINITIONS ---

/// Main entry point for the protoc plugin.
/// Reads CodeGeneratorRequest from stdin, generates Python code,
/// and writes CodeGeneratorResponse to stdout.
fn main() -> Result<()> {
    // Read the CodeGeneratorRequest from stdin
    let mut input_bytes = vec![];
    io::stdin().read_to_end(&mut input_bytes)?;

    let request = CodeGeneratorRequest::decode(input_bytes.as_ref())
        .context("Failed to decode CodeGeneratorRequest")?;

    let mut types_module_import = String::new();

    // Parse parameters, if any
    if request.parameter.is_some() {
        // Split by , and process parameters in the form key=value
        for param in request.parameter.as_ref().unwrap().split(',') {
            let mut parts = param.splitn(2, '=');
            if let (Some(key), Some(value)) = (parts.next(), parts.next()) {
                // Handle parameter
                match key {
                    TYPES_IMPORT => {
                        types_module_import = value.to_string();
                    }
                    _ => {
                        return Err(anyhow::anyhow!("Unknown parameter: {}", key));
                    }
                }
            } else {
                return Err(anyhow::anyhow!("Invalid parameter format: {}", param));
            }
        }
    }

    let mut response = CodeGeneratorResponse::default();

    // Map proto file names to their package names for easy lookup
    let file_to_package: HashMap<String, String> = request
        .proto_file
        .iter()
        .filter_map(|f| {
            f.name
                .as_ref()
                .map(|name| (name.clone(), f.package.clone().unwrap_or_default()))
        })
        .collect();

    // Iterate through each .proto file provided in the request
    for file_descriptor in request.proto_file {
        // Only process files that are explicitly requested for generation
        if !request
            .file_to_generate
            .contains(&file_descriptor.name.clone().unwrap_or_default())
        {
            continue;
        }

        let package_name = file_descriptor.package.clone().unwrap_or_default();
        let file_name_base = file_descriptor
            .name
            .as_ref()
            .and_then(|name| name.strip_suffix(".proto"))
            .map(|name| name.to_snake_case())
            .unwrap_or_else(|| "unknown_proto".to_string());

        // The generated Python file will be named after the proto file,
        // with a '_pb2_slimrpc' suffix
        let output_file_name = format!("{}_pb2_slimrpc.py", file_name_base);

        let mut pb2_imports: HashSet<String> = HashSet::new();
        let mut service_definitions_content = String::new();
        let mut add_servicer_functions_content = String::new();
        let mut services_found = false;

        if types_module_import.is_empty() {
            let local_pb2_module = format!("{}_pb2", file_name_base);
            types_module_import = format!("from . import {} as pb2", local_pb2_module);
        }

        pb2_imports.insert(types_module_import.clone());

        // Helper function to resolve the full Python path for a message type
        let mut resolve_type_path = |full_type_name: &str, current_file_package: &str| -> String {
            let trimmed_name = full_type_name.trim_start_matches('.');
            let parts: Vec<&str> = trimmed_name.split('.').collect();
            let type_name = parts.last().unwrap_or(&"").to_string();
            let package_path = parts[..parts.len() - 1].join(".");

            if trimmed_name.starts_with("google.protobuf.") {
                let module_name = format!("google.protobuf.{}_pb2", type_name.to_snake_case());
                let alias_name = module_name.replace('.', "__");
                pb2_imports.insert(format!("import {} as {}", module_name, alias_name));
                return format!("{}.{}", alias_name, type_name);
            }

            if package_path == current_file_package {
                let mut prefix = "pb2.".to_string();

                if !types_module_import.is_empty() {
                    // Get last word from the import and add a .
                    prefix = format!(
                        "{}.",
                        types_module_import
                            .split_whitespace()
                            .last()
                            .unwrap_or(&prefix)
                    );
                }

                format!("{}{}", prefix, type_name)
            } else {
                let mut dep_file_base_name = String::new();
                for (file_name, file_package) in file_to_package.iter() {
                    if file_package == &package_path {
                        dep_file_base_name = file_name
                            .strip_suffix(".proto")
                            .unwrap_or(file_name)
                            .to_string()
                            .to_snake_case();
                        break;
                    }
                }

                if !dep_file_base_name.is_empty() {
                    let dep_pb2_module = format!("{}_pb2", dep_file_base_name);
                    pb2_imports.insert(format!(
                        "from . import {} as {}",
                        dep_pb2_module, dep_pb2_module
                    ));
                    format!("{}.{}", dep_pb2_module, type_name)
                } else {
                    // Fallback to local import if package is not found
                    format!("pb2.{}", type_name)
                }
            }
        };

        // Iterate through services defined in the current .proto file
        for service in file_descriptor.service {
            services_found = true;
            let service_name = service.name.context("Service name missing")?;

            let mut method_stub_initializers_content = String::new();
            let mut method_servicers_content = String::new();
            let mut rpc_method_handlers_content = String::new();

            // Generate methods for the client stub and server servicer
            for method in service.method {
                let method_name = method.name.clone().context("Method name missing")?;
                let input_type = method.input_type.clone().context("Input type missing")?;
                let output_type = method.output_type.clone().context("Output type missing")?;

                let input_type_full_path = resolve_type_path(&input_type, &package_name);
                let output_type_full_path = resolve_type_path(&output_type, &package_name);

                let is_client_streaming = method.client_streaming.unwrap_or(false);
                let is_server_streaming = method.server_streaming.unwrap_or(false);

                let rpc_type = match (is_client_streaming, is_server_streaming) {
                    (false, false) => "unary_unary",
                    (false, true) => "unary_stream",
                    (true, false) => "stream_unary",
                    (true, true) => "stream_stream",
                };

                let request_arg = if is_client_streaming {
                    "request_iterator"
                } else {
                    "request"
                };

                // Populate method stub initializer template
                let current_method_stub_initializer = METHOD_STUB_INITIALIZER_TEMPLATE
                    .replace("{{METHOD_NAME}}", &method_name)
                    .replace("{{RPC_TYPE}}", rpc_type)
                    .replace("{{PACKAGE_NAME}}", &package_name)
                    .replace("{{SERVICE_NAME}}", &service_name)
                    .replace("{{INPUT_TYPE_FULL_PATH}}", &input_type_full_path)
                    .replace("{{OUTPUT_TYPE_FULL_PATH}}", &output_type_full_path);
                method_stub_initializers_content.push_str(&current_method_stub_initializer);

                // Populate method servicer template
                let current_method_servicer = METHOD_SERVICER_TEMPLATE
                    .replace("{{METHOD_NAME}}", &method_name)
                    .replace("{{REQUEST_ARG}}", request_arg)
                    .replace("{{INPUT_TYPE_FULL_PATH}}", &input_type_full_path);
                method_servicers_content.push_str(&current_method_servicer);

                // Populate RPC method handler template
                let current_rpc_method_handler = RPC_METHOD_HANDLER_TEMPLATE
                    .replace("{{METHOD_NAME}}", &method_name)
                    .replace("{{RPC_TYPE}}", rpc_type)
                    .replace("{{INPUT_TYPE_FULL_PATH}}", &input_type_full_path)
                    .replace("{{OUTPUT_TYPE_FULL_PATH}}", &output_type_full_path);
                rpc_method_handlers_content.push_str(&current_rpc_method_handler);
            }

            // Populate service stub template
            let current_service_stub = SERVICE_STUB_TEMPLATE
                .replace("{{SERVICE_NAME}}", &service_name)
                .replace(
                    "{{METHOD_STUB_INITIALIZERS}}",
                    &method_stub_initializers_content,
                );
            service_definitions_content.push_str(&current_service_stub);

            // Populate service servicer template
            let current_service_servicer = SERVICE_SERVICER_TEMPLATE
                .replace("{{SERVICE_NAME}}", &service_name)
                .replace("{{METHOD_SERVICERS}}", &method_servicers_content);
            service_definitions_content.push_str(&current_service_servicer);

            // Populate add servicer function template
            let current_add_servicer_function = ADD_SERVICER_FUNCTION_TEMPLATE
                .replace("{{SERVICE_NAME}}", &service_name)
                .replace("{{PACKAGE_NAME}}", &package_name)
                .replace("{{RPC_METHOD_HANDLERS}}", &rpc_method_handlers_content);
            add_servicer_functions_content.push_str(&current_add_servicer_function);
        }

        // Only add a file to the response if services were found and generated
        if services_found {
            let pb2_imports_string = pb2_imports.into_iter().collect::<Vec<_>>().join("\n");
            let final_content = FILE_TEMPLATE
                .replace("{{PB2_IMPORTS}}", &pb2_imports_string)
                .replace("{{SERVICE_DEFINITIONS}}", &service_definitions_content)
                .replace(
                    "{{ADD_SERVICER_FUNCTIONS}}",
                    &add_servicer_functions_content,
                );

            response.file.push(File {
                name: Some(output_file_name),
                content: Some(final_content),
                ..Default::default()
            });
        }
    }

    // Write the CodeGeneratorResponse to stdout
    let output_bytes = response.encode_to_vec();
    io::stdout().write_all(&output_bytes)?;

    Ok(())
}
