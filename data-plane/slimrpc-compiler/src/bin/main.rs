// Copyright AGNTCY Contributors (https://github.com/agntcy)
// SPDX-License-Identifier: Apache-2.0

use anyhow::{Context, Result};
use heck::ToSnakeCase;
use prost::Message;
use prost_types::compiler::{
    CodeGeneratorRequest, CodeGeneratorResponse, code_generator_response::File,
};
use std::collections::{HashMap, HashSet};
use std::io::{self, Read, Write};

/// Supported parameters for the code generator plugin.
const TYPES_IMPORT: &str = "types_import";

// --- TEMPLATE DEFINITIONS ---

const FILE_TEMPLATE: &str = r#"# Generated by protoc-slimrpc-plugin
# This file is generated from an embedded template. Do not edit directly.

import slimrpc
from slimrpc import rpc as slimrpc_rpc

from google.rpc import code_pb2 as code__pb2

{{PB2_IMPORTS}}

{{SERVICE_DEFINITIONS}}

{{ADD_SERVICER_FUNCTIONS}}
"#;

const SERVICE_STUB_TEMPLATE: &str = r#"
class {{SERVICE_NAME}}Stub:
    """Client stub for {{SERVICE_NAME}}."""
    def __init__(self, channel):
        """Constructor.

        Args:
            channel: A slimrpc.Channel.
        """
{{METHOD_STUB_INITIALIZERS}}
"#;

const METHOD_STUB_INITIALIZER_TEMPLATE: &str = r#"        self.{{METHOD_NAME}} = channel.{{RPC_TYPE}}(
            "/{{PACKAGE_NAME}}.{{SERVICE_NAME}}/{{METHOD_NAME}}",
            request_serializer={{INPUT_TYPE_FULL_PATH}}.SerializeToString,
            response_deserializer={{OUTPUT_TYPE_FULL_PATH}}.FromString,
        )
"#;

const SERVICE_SERVICER_TEMPLATE: &str = r#"
class {{SERVICE_NAME}}Servicer():
    """Server servicer for {{SERVICE_NAME}}. Implement this class to provide your service logic."""

{{METHOD_SERVICERS}}
"#;

const STREAM_METHOD_SERVICER_TEMPLATE: &str = r#"    def {{METHOD_NAME}}(self, request_iterator, session_context):
        """Method for {{METHOD_NAME}}. Implement your service logic here."""
        raise slimrpc_rpc.SRPCResponseError(
            code=code__pb2.UNIMPLEMENTED, message="Method not implemented!"
        )
"#;

const UNARY_METHOD_SERVICER_TEMPLATE: &str = r#"    def {{METHOD_NAME}}(self, request, msg_context, session_context):
        """Method for {{METHOD_NAME}}. Implement your service logic here."""
        raise slimrpc_rpc.SRPCResponseError(
            code=code__pb2.UNIMPLEMENTED, message="Method not implemented!"
        )
"#;

const ADD_SERVICER_FUNCTION_TEMPLATE: &str = r#"
def add_{{SERVICE_NAME}}Servicer_to_server(servicer, server: slimrpc.Server):
    rpc_method_handlers = {
{{RPC_METHOD_HANDLERS}}
    }

    server.register_method_handlers(
        "{{PACKAGE_NAME}}.{{SERVICE_NAME}}",
        rpc_method_handlers,
    )
"#;

const RPC_METHOD_HANDLER_TEMPLATE: &str = r#"        "{{METHOD_NAME}}": slimrpc.{{RPC_TYPE}}_rpc_method_handler(
            behaviour=servicer.{{METHOD_NAME}},
            request_deserializer={{INPUT_TYPE_FULL_PATH}}.FromString,
            response_serializer={{OUTPUT_TYPE_FULL_PATH}}.SerializeToString,
        ),
"#;

// --- END TEMPLATE DEFINITIONS ---

/// Main entry point for the protoc plugin.
/// Reads CodeGeneratorRequest from stdin, generates Python code,
/// and writes CodeGeneratorResponse to stdout.
fn main() -> Result<()> {
    // Read the CodeGeneratorRequest from stdin
    let mut input_bytes = vec![];
    io::stdin().read_to_end(&mut input_bytes)?;

    let request = CodeGeneratorRequest::decode(input_bytes.as_ref())
        .context("Failed to decode CodeGeneratorRequest")?;

    let response = handle_code_generation(request)?;

    // Write the CodeGeneratorResponse to stdout
    let output_bytes = response.encode_to_vec();
    io::stdout().write_all(&output_bytes)?;

    Ok(())
}

fn handle_code_generation(request: CodeGeneratorRequest) -> Result<CodeGeneratorResponse> {
    let mut types_module_import = String::new();

    // Parse parameters, if any
    if let Some(p) = &request.parameter {
        // Split by , and process parameters in the form key=value
        for param in p.split(',') {
            let mut parts = param.splitn(2, '=');
            if let (Some(key), Some(value)) = (parts.next(), parts.next()) {
                // Handle parameter
                match key {
                    TYPES_IMPORT => {
                        types_module_import = value.to_string();
                    }
                    _ => {
                        return Err(anyhow::anyhow!("Unknown parameter: {}", key));
                    }
                }
            } else {
                return Err(anyhow::anyhow!("Invalid parameter format: {}", param));
            }
        }
    }

    let mut response = CodeGeneratorResponse::default();

    // Map proto file names to their package names for easy lookup
    let file_to_package: HashMap<String, String> = request
        .proto_file
        .iter()
        .filter_map(|f| {
            f.name
                .as_ref()
                .map(|name| (name.clone(), f.package.clone().unwrap_or_default()))
        })
        .collect();

    // Iterate through each .proto file provided in the request
    for file_descriptor in request.proto_file {
        // Only process files that are explicitly requested for generation
        if !request
            .file_to_generate
            .contains(&file_descriptor.name.clone().unwrap_or_default())
        {
            continue;
        }

        let package_name = file_descriptor.package.clone().unwrap_or_default();
        let file_name_base = file_descriptor
            .name
            .as_ref()
            .and_then(|name| name.strip_suffix(".proto"))
            .map(|name| name.to_snake_case())
            .unwrap_or_else(|| "unknown_proto".to_string());

        // The generated Python file will be named after the proto file,
        // with a '_pb2_slimrpc' suffix
        let output_file_name = format!("{}_pb2_slimrpc.py", file_name_base);

        let mut pb2_imports: HashSet<String> = HashSet::new();
        let mut service_definitions_content = String::new();
        let mut add_servicer_functions_content = String::new();
        let mut services_found = false;

        if types_module_import.is_empty() {
            let local_pb2_module = format!("{}_pb2", file_name_base);
            types_module_import = format!("from . import {} as pb2", local_pb2_module);
        }

        pb2_imports.insert(types_module_import.clone());

        // Helper function to resolve the full Python path for a message type
        let mut resolve_type_path = |full_type_name: &str, current_file_package: &str| -> String {
            let trimmed_name = full_type_name.trim_start_matches('.');
            let parts: Vec<&str> = trimmed_name.split('.').collect();
            let type_name = parts.last().unwrap_or(&"").to_string();
            let package_path = parts[..parts.len() - 1].join(".");

            if trimmed_name.starts_with("google.protobuf.") {
                let module_name = format!("google.protobuf.{}_pb2", type_name.to_snake_case());
                let alias_name = module_name.replace('.', "__");
                pb2_imports.insert(format!("import {} as {}", module_name, alias_name));
                return format!("{}.{}", alias_name, type_name);
            }

            if package_path == current_file_package {
                let mut prefix = "pb2.".to_string();

                if !types_module_import.is_empty() {
                    // Get last word from the import and add a .
                    prefix = format!(
                        "{}.",
                        types_module_import
                            .split_whitespace()
                            .last()
                            .unwrap_or(&prefix)
                    );
                }

                format!("{}{}", prefix, type_name)
            } else {
                let mut dep_file_base_name = String::new();
                for (file_name, file_package) in file_to_package.iter() {
                    if file_package == &package_path {
                        dep_file_base_name = file_name
                            .strip_suffix(".proto")
                            .unwrap_or(file_name)
                            .to_string()
                            .to_snake_case();
                        break;
                    }
                }

                if !dep_file_base_name.is_empty() {
                    let dep_pb2_module = format!("{}_pb2", dep_file_base_name);
                    pb2_imports.insert(format!(
                        "from . import {} as {}",
                        dep_pb2_module, dep_pb2_module
                    ));
                    format!("{}.{}", dep_pb2_module, type_name)
                } else {
                    // Fallback to local import if package is not found
                    format!("pb2.{}", type_name)
                }
            }
        };

        // Iterate through services defined in the current .proto file
        for service in file_descriptor.service {
            services_found = true;
            let service_name = service.name.context("Service name missing")?;

            let mut method_stub_initializers_content = String::new();
            let mut method_servicers_content = String::new();
            let mut rpc_method_handlers_content = String::new();

            // Generate methods for the client stub and server servicer
            for method in service.method {
                let method_name = method.name.clone().context("Method name missing")?;
                let input_type = method.input_type.clone().context("Input type missing")?;
                let output_type = method.output_type.clone().context("Output type missing")?;

                let input_type_full_path = resolve_type_path(&input_type, &package_name);
                let output_type_full_path = resolve_type_path(&output_type, &package_name);

                let is_client_streaming = method.client_streaming.unwrap_or(false);
                let is_server_streaming = method.server_streaming.unwrap_or(false);

                let rpc_type = match (is_client_streaming, is_server_streaming) {
                    (false, false) => "unary_unary",
                    (false, true) => "unary_stream",
                    (true, false) => "stream_unary",
                    (true, true) => "stream_stream",
                };

                let method_template = if is_client_streaming {
                    STREAM_METHOD_SERVICER_TEMPLATE
                } else {
                    UNARY_METHOD_SERVICER_TEMPLATE
                };

                // Populate method stub initializer template
                let current_method_stub_initializer = METHOD_STUB_INITIALIZER_TEMPLATE
                    .replace("{{METHOD_NAME}}", &method_name)
                    .replace("{{RPC_TYPE}}", rpc_type)
                    .replace("{{PACKAGE_NAME}}", &package_name)
                    .replace("{{SERVICE_NAME}}", &service_name)
                    .replace("{{INPUT_TYPE_FULL_PATH}}", &input_type_full_path)
                    .replace("{{OUTPUT_TYPE_FULL_PATH}}", &output_type_full_path);
                method_stub_initializers_content.push_str(&current_method_stub_initializer);

                // Populate method servicer template
                let current_method_servicer = method_template
                    .replace("{{METHOD_NAME}}", &method_name)
                    .replace("{{INPUT_TYPE_FULL_PATH}}", &input_type_full_path);
                method_servicers_content.push_str(&current_method_servicer);

                // Populate RPC method handler template
                let current_rpc_method_handler = RPC_METHOD_HANDLER_TEMPLATE
                    .replace("{{METHOD_NAME}}", &method_name)
                    .replace("{{RPC_TYPE}}", rpc_type)
                    .replace("{{INPUT_TYPE_FULL_PATH}}", &input_type_full_path)
                    .replace("{{OUTPUT_TYPE_FULL_PATH}}", &output_type_full_path);
                rpc_method_handlers_content.push_str(&current_rpc_method_handler);
            }

            // Populate service stub template
            let current_service_stub = SERVICE_STUB_TEMPLATE
                .replace("{{SERVICE_NAME}}", &service_name)
                .replace(
                    "{{METHOD_STUB_INITIALIZERS}}",
                    &method_stub_initializers_content,
                );
            service_definitions_content.push_str(&current_service_stub);

            // Populate service servicer template
            let current_service_servicer = SERVICE_SERVICER_TEMPLATE
                .replace("{{SERVICE_NAME}}", &service_name)
                .replace("{{METHOD_SERVICERS}}", &method_servicers_content);
            service_definitions_content.push_str(&current_service_servicer);

            // Populate add servicer function template
            let current_add_servicer_function = ADD_SERVICER_FUNCTION_TEMPLATE
                .replace("{{SERVICE_NAME}}", &service_name)
                .replace("{{PACKAGE_NAME}}", &package_name)
                .replace("{{RPC_METHOD_HANDLERS}}", &rpc_method_handlers_content);
            add_servicer_functions_content.push_str(&current_add_servicer_function);
        }

        // Only add a file to the response if services were found and generated
        if services_found {
            let pb2_imports_string = pb2_imports.into_iter().collect::<Vec<_>>().join("\n");
            let final_content = FILE_TEMPLATE
                .replace("{{PB2_IMPORTS}}", &pb2_imports_string)
                .replace("{{SERVICE_DEFINITIONS}}", &service_definitions_content)
                .replace(
                    "{{ADD_SERVICER_FUNCTIONS}}",
                    &add_servicer_functions_content,
                );

            response.file.push(File {
                name: Some(output_file_name),
                content: Some(final_content),
                ..Default::default()
            });
        }
    }

    Ok(response)
}

#[cfg(test)]
mod tests {
    use super::*;
    use prost_types::{FileDescriptorProto, MethodDescriptorProto, ServiceDescriptorProto};

    /// Helper function to create a basic FileDescriptorProto for testing
    fn create_test_file_descriptor(
        name: &str,
        package: &str,
        services: Vec<ServiceDescriptorProto>,
    ) -> FileDescriptorProto {
        FileDescriptorProto {
            name: Some(name.to_string()),
            package: Some(package.to_string()),
            service: services,
            message_type: vec![],
            enum_type: vec![],
            dependency: vec![],
            public_dependency: vec![],
            weak_dependency: vec![],
            extension: vec![],
            options: None,
            source_code_info: None,
            syntax: None,
        }
    }

    /// Helper function to create a basic MethodDescriptorProto for testing
    fn create_test_method(
        name: &str,
        input_type: &str,
        output_type: &str,
        client_streaming: bool,
        server_streaming: bool,
    ) -> MethodDescriptorProto {
        MethodDescriptorProto {
            name: Some(name.to_string()),
            input_type: Some(input_type.to_string()),
            output_type: Some(output_type.to_string()),
            client_streaming: Some(client_streaming),
            server_streaming: Some(server_streaming),
            options: None,
        }
    }

    /// Helper function to create a basic ServiceDescriptorProto for testing
    fn create_test_service(
        name: &str,
        methods: Vec<MethodDescriptorProto>,
    ) -> ServiceDescriptorProto {
        ServiceDescriptorProto {
            name: Some(name.to_string()),
            method: methods,
            options: None,
        }
    }

    #[test]
    fn test_handle_code_generation_no_services() {
        // Test with a proto file that has no services
        let request = CodeGeneratorRequest {
            file_to_generate: vec!["test.proto".to_string()],
            parameter: None,
            proto_file: vec![create_test_file_descriptor(
                "test.proto",
                "test.package",
                vec![],
            )],
            compiler_version: None,
        };

        let response = handle_code_generation(request).unwrap();

        // Should not generate any files since there are no services
        assert_eq!(response.file.len(), 0);
    }

    #[test]
    fn test_handle_code_generation_with_unary_unary_method() {
        // Test with a simple unary-unary RPC method
        let method = create_test_method(
            "GetUser",
            ".test.package.GetUserRequest",
            ".test.package.GetUserResponse",
            false,
            false,
        );
        let service = create_test_service("UserService", vec![method]);
        let file_descriptor =
            create_test_file_descriptor("user.proto", "test.package", vec![service]);

        let request = CodeGeneratorRequest {
            file_to_generate: vec!["user.proto".to_string()],
            parameter: None,
            proto_file: vec![file_descriptor],
            compiler_version: None,
        };

        let response = handle_code_generation(request).unwrap();

        assert_eq!(response.file.len(), 1);
        let generated_file = &response.file[0];
        assert_eq!(generated_file.name.as_ref().unwrap(), "user_pb2_slimrpc.py");

        let content = generated_file.content.as_ref().unwrap();
        assert!(content.contains("class UserServiceStub:"));
        assert!(content.contains("class UserServiceServicer():"));
        assert!(content.contains("def GetUser(self, request, msg_context, session_context):"));
        assert!(
            content.contains(
                "def add_UserServiceServicer_to_server(servicer, server: slimrpc.Server):"
            )
        );
        assert!(content.contains("unary_unary"));
    }

    #[test]
    fn test_handle_code_generation_with_streaming_methods() {
        // Test with all streaming combinations
        let methods = vec![
            create_test_method(
                "UnaryToStream",
                ".pkg.Request",
                ".pkg.Response",
                false,
                true,
            ),
            create_test_method(
                "StreamToUnary",
                ".pkg.Request",
                ".pkg.Response",
                true,
                false,
            ),
            create_test_method(
                "StreamToStream",
                ".pkg.Request",
                ".pkg.Response",
                true,
                true,
            ),
        ];
        let service = create_test_service("StreamService", methods);
        let file_descriptor = create_test_file_descriptor("stream.proto", "pkg", vec![service]);

        let request = CodeGeneratorRequest {
            file_to_generate: vec!["stream.proto".to_string()],
            parameter: None,
            proto_file: vec![file_descriptor],
            compiler_version: None,
        };

        let response = handle_code_generation(request).unwrap();

        assert_eq!(response.file.len(), 1);
        let content = response.file[0].content.as_ref().unwrap();

        assert!(content.contains("unary_stream"));
        assert!(content.contains("stream_unary"));
        assert!(content.contains("stream_stream"));
        assert!(
            content.contains("def UnaryToStream(self, request, msg_context, session_context):")
        );
        assert!(content.contains("def StreamToUnary(self, request_iterator, session_context):"));
        assert!(content.contains("def StreamToStream(self, request_iterator, session_context):"));
    }

    #[test]
    fn test_handle_code_generation_with_types_import_parameter() {
        // Test with custom types_import parameter
        let method = create_test_method("Echo", ".test.Echo", ".test.Echo", false, false);
        let service = create_test_service("TestService", vec![method]);
        let file_descriptor = create_test_file_descriptor("test.proto", "test", vec![service]);

        let request = CodeGeneratorRequest {
            file_to_generate: vec!["test.proto".to_string()],
            parameter: Some("types_import=from mymodule import types as pb2".to_string()),
            proto_file: vec![file_descriptor],
            compiler_version: None,
        };

        let response = handle_code_generation(request).unwrap();

        assert_eq!(response.file.len(), 1);
        let content = response.file[0].content.as_ref().unwrap();
        assert!(content.contains("from mymodule import types as pb2"));
    }

    #[test]
    fn test_handle_code_generation_with_invalid_parameter() {
        // Test with an unknown parameter
        let method = create_test_method("Test", ".test.Req", ".test.Res", false, false);
        let service = create_test_service("TestService", vec![method]);
        let file_descriptor = create_test_file_descriptor("test.proto", "test", vec![service]);

        let request = CodeGeneratorRequest {
            file_to_generate: vec!["test.proto".to_string()],
            parameter: Some("unknown_param=value".to_string()),
            proto_file: vec![file_descriptor],
            compiler_version: None,
        };

        let result = handle_code_generation(request);
        assert!(result.is_err());
        assert!(
            result
                .unwrap_err()
                .to_string()
                .contains("Unknown parameter")
        );
    }

    #[test]
    fn test_handle_code_generation_with_invalid_parameter_format() {
        // Test with invalid parameter format (no equals sign)
        let method = create_test_method("Test", ".test.Req", ".test.Res", false, false);
        let service = create_test_service("TestService", vec![method]);
        let file_descriptor = create_test_file_descriptor("test.proto", "test", vec![service]);

        let request = CodeGeneratorRequest {
            file_to_generate: vec!["test.proto".to_string()],
            parameter: Some("invalid_format".to_string()),
            proto_file: vec![file_descriptor],
            compiler_version: None,
        };

        let result = handle_code_generation(request);
        assert!(result.is_err());
        assert!(
            result
                .unwrap_err()
                .to_string()
                .contains("Invalid parameter format")
        );
    }

    #[test]
    fn test_handle_code_generation_multiple_services() {
        // Test with multiple services in the same file
        let method1 = create_test_method("Method1", ".pkg.Req1", ".pkg.Res1", false, false);
        let method2 = create_test_method("Method2", ".pkg.Req2", ".pkg.Res2", false, false);

        let service1 = create_test_service("Service1", vec![method1]);
        let service2 = create_test_service("Service2", vec![method2]);

        let file_descriptor =
            create_test_file_descriptor("multi.proto", "pkg", vec![service1, service2]);

        let request = CodeGeneratorRequest {
            file_to_generate: vec!["multi.proto".to_string()],
            parameter: None,
            proto_file: vec![file_descriptor],
            compiler_version: None,
        };

        let response = handle_code_generation(request).unwrap();

        assert_eq!(response.file.len(), 1);
        let content = response.file[0].content.as_ref().unwrap();

        assert!(content.contains("class Service1Stub:"));
        assert!(content.contains("class Service1Servicer():"));
        assert!(content.contains("class Service2Stub:"));
        assert!(content.contains("class Service2Servicer():"));
        assert!(content.contains("def add_Service1Servicer_to_server"));
        assert!(content.contains("def add_Service2Servicer_to_server"));
    }

    #[test]
    fn test_handle_code_generation_not_in_files_to_generate() {
        // Test that files not in file_to_generate are skipped
        let method = create_test_method("Test", ".pkg.Req", ".pkg.Res", false, false);
        let service = create_test_service("TestService", vec![method]);
        let file_descriptor = create_test_file_descriptor("test.proto", "pkg", vec![service]);

        let request = CodeGeneratorRequest {
            file_to_generate: vec!["other.proto".to_string()], // Different file
            parameter: None,
            proto_file: vec![file_descriptor],
            compiler_version: None,
        };

        let response = handle_code_generation(request).unwrap();

        // Should not generate any files since test.proto is not in file_to_generate
        assert_eq!(response.file.len(), 0);
    }

    #[test]
    fn test_handle_code_generation_snake_case_file_name() {
        // Test that file names are converted to snake_case
        let method = create_test_method("Test", ".pkg.Req", ".pkg.Res", false, false);
        let service = create_test_service("TestService", vec![method]);
        let file_descriptor =
            create_test_file_descriptor("CamelCaseFile.proto", "pkg", vec![service]);

        let request = CodeGeneratorRequest {
            file_to_generate: vec!["CamelCaseFile.proto".to_string()],
            parameter: None,
            proto_file: vec![file_descriptor],
            compiler_version: None,
        };

        let response = handle_code_generation(request).unwrap();

        assert_eq!(response.file.len(), 1);
        assert_eq!(
            response.file[0].name.as_ref().unwrap(),
            "camel_case_file_pb2_slimrpc.py"
        );
    }

    #[test]
    fn test_handle_code_generation_empty_package_name() {
        // Test with empty package name
        let method = create_test_method("Test", ".Req", ".Res", false, false);
        let service = create_test_service("TestService", vec![method]);
        let file_descriptor = create_test_file_descriptor("test.proto", "", vec![service]);

        let request = CodeGeneratorRequest {
            file_to_generate: vec!["test.proto".to_string()],
            parameter: None,
            proto_file: vec![file_descriptor],
            compiler_version: None,
        };

        let response = handle_code_generation(request).unwrap();

        assert_eq!(response.file.len(), 1);
        // Should still generate valid code
        let content = response.file[0].content.as_ref().unwrap();
        assert!(content.contains("class TestServiceStub:"));
    }

    #[test]
    fn test_handle_code_generation_multiple_parameters() {
        // Test with multiple comma-separated parameters
        let method = create_test_method("Test", ".test.Req", ".test.Res", false, false);
        let service = create_test_service("TestService", vec![method]);
        let file_descriptor = create_test_file_descriptor("test.proto", "test", vec![service]);

        let request = CodeGeneratorRequest {
            file_to_generate: vec!["test.proto".to_string()],
            parameter: Some("types_import=from custom import pb2".to_string()),
            proto_file: vec![file_descriptor],
            compiler_version: None,
        };

        let response = handle_code_generation(request).unwrap();

        assert_eq!(response.file.len(), 1);
        let content = response.file[0].content.as_ref().unwrap();
        assert!(content.contains("from custom import pb2"));
    }

    #[test]
    fn test_handle_code_generation_google_protobuf_types() {
        // Test with google.protobuf types (like Empty)
        let method = create_test_method(
            "TestEmpty",
            ".google.protobuf.Empty",
            ".test.Response",
            false,
            false,
        );
        let service = create_test_service("TestService", vec![method]);
        let file_descriptor = create_test_file_descriptor("test.proto", "test", vec![service]);

        let request = CodeGeneratorRequest {
            file_to_generate: vec!["test.proto".to_string()],
            parameter: None,
            proto_file: vec![file_descriptor],
            compiler_version: None,
        };

        let response = handle_code_generation(request).unwrap();

        assert_eq!(response.file.len(), 1);
        let content = response.file[0].content.as_ref().unwrap();
        // Should import google.protobuf types correctly
        assert!(content.contains("google.protobuf.empty_pb2"));
    }

    #[test]
    fn test_handle_code_generation_service_with_multiple_methods() {
        // Test service with multiple methods
        let methods = vec![
            create_test_method("Create", ".pkg.CreateReq", ".pkg.CreateRes", false, false),
            create_test_method("Read", ".pkg.ReadReq", ".pkg.ReadRes", false, false),
            create_test_method("Update", ".pkg.UpdateReq", ".pkg.UpdateRes", false, false),
            create_test_method("Delete", ".pkg.DeleteReq", ".pkg.DeleteRes", false, false),
        ];
        let service = create_test_service("CrudService", methods);
        let file_descriptor = create_test_file_descriptor("crud.proto", "pkg", vec![service]);

        let request = CodeGeneratorRequest {
            file_to_generate: vec!["crud.proto".to_string()],
            parameter: None,
            proto_file: vec![file_descriptor],
            compiler_version: None,
        };

        let response = handle_code_generation(request).unwrap();

        assert_eq!(response.file.len(), 1);
        let content = response.file[0].content.as_ref().unwrap();

        assert!(content.contains("def Create("));
        assert!(content.contains("def Read("));
        assert!(content.contains("def Update("));
        assert!(content.contains("def Delete("));
        assert!(content.contains("self.Create = channel.unary_unary"));
        assert!(content.contains("self.Read = channel.unary_unary"));
        assert!(content.contains("self.Update = channel.unary_unary"));
        assert!(content.contains("self.Delete = channel.unary_unary"));
    }

    #[test]
    fn test_handle_code_generation_cross_package_dependency() {
        // Test the else branch where package_path != current_file_package (line 214)
        // This tests types from a different package that IS found in file_to_package

        // Create a dependency proto file with its own package
        let dep_file_descriptor = create_test_file_descriptor(
            "common/types.proto",
            "common.types",
            vec![], // No services in dependency
        );

        // Create the main service that uses types from the dependency package
        let method = create_test_method(
            "ProcessRequest",
            ".common.types.CommonRequest", // Type from different package
            ".service.pkg.ServiceResponse", // Type from current package
            false,
            false,
        );
        let service = create_test_service("MyService", vec![method]);
        let main_file_descriptor =
            create_test_file_descriptor("service/api.proto", "service.pkg", vec![service]);

        let request = CodeGeneratorRequest {
            file_to_generate: vec!["service/api.proto".to_string()],
            parameter: None,
            proto_file: vec![dep_file_descriptor, main_file_descriptor],
            compiler_version: None,
        };

        let response = handle_code_generation(request).unwrap();

        assert_eq!(response.file.len(), 1);
        let content = response.file[0].content.as_ref().unwrap();

        // Should import the dependency package
        assert!(content.contains("from . import common_types_pb2 as common_types_pb2"));
        // Should use the imported module for the cross-package type
        assert!(content.contains("common_types_pb2.CommonRequest"));
        // Should use pb2 prefix for local package type
        assert!(content.contains("pb2.ServiceResponse"));
    }

    #[test]
    fn test_handle_code_generation_cross_package_type_not_found() {
        // Test the fallback else case when package is not found (lines 234-237)
        // This happens when a type references a package not in file_to_package map
        let method = create_test_method(
            "ProcessData",
            ".unknown.package.Request", // Package not in proto_file list
            ".test.package.Response",
            false,
            false,
        );
        let service = create_test_service("DataService", vec![method]);
        let file_descriptor =
            create_test_file_descriptor("data.proto", "test.package", vec![service]);

        let request = CodeGeneratorRequest {
            file_to_generate: vec!["data.proto".to_string()],
            parameter: None,
            proto_file: vec![file_descriptor],
            compiler_version: None,
        };

        let response = handle_code_generation(request).unwrap();

        assert_eq!(response.file.len(), 1);
        let content = response.file[0].content.as_ref().unwrap();

        // When package is not found, it should fallback to local pb2 import
        assert!(content.contains("pb2.Request"));
        assert!(content.contains("request_deserializer=pb2.Request.FromString"));
        assert!(content.contains("class DataServiceStub:"));
    }
}
